(window.webpackJsonp=window.webpackJsonp||[]).push([[141],{1024:function(e,n,t){"use strict";t.r(n),t.d(n,"monitor_line_chart",(function(){return c}));var i=t(61),r=(t(1130),t(1132)),o=(t(1133),t(1134),t(1138),t(1169)),a=(t(1143),t(1139),t(1155),t(1162),t(1163),t(1151),t(1145),t(1153),t(1147),t(1141),t(1171)),s=r.c.DATA_ALIGNMENT,l=function(e){return Object(i.h)("monitor-tooltip",Object.assign({},e,{visualizesAlarms:!1,supportString:!1,dataAlignment:s.EITHER}))},c=function(){function e(e){Object(i.i)(this,e),this.gestures=!0,this.isEditing=!1,this.bufferFactor=2,this.minBufferSize=1e3}return e.prototype.render=function(){var e=this;return Object(i.h)("monitor-size-provider",{size:this.size,renderFunc:function(n){return Object(i.h)("monitor-webgl-base-chart",{axis:e.axis,alarms:e.alarms,gestures:e.gestures,configId:e.widgetId,requestData:e.requestData,legend:e.legend,annotations:e.annotations,trends:e.trends,updateChartScene:a.b,createChartScene:a.a,size:Object.assign(Object.assign(Object.assign({},o.a.size),e.size),n),dataStreams:e.dataStreams,viewPort:e.viewPort,minBufferSize:e.minBufferSize,bufferFactor:e.bufferFactor,isEditing:e.isEditing,tooltip:l,supportString:!1,visualizesAlarms:!1,messageOverrides:e.messageOverrides})}})},e}()},1154:function(e,n,t){"use strict";t.d(n,"a",(function(){return c})),t.d(n,"b",(function(){return p})),t.d(n,"c",(function(){return d})),t.d(n,"d",(function(){return m})),t.d(n,"e",(function(){return u})),t.d(n,"f",(function(){return g}));var i=t(68),r=t(1142),o=t(1137),a=t(1144),s=t(1140),l=function(e){return"\nvarying vec3 vColor;\n"+(e?"varying float positionY;":"")+"\nattribute vec3 pointColor;\nuniform float pointDiameter;\nuniform float devicePixelRatio;\n\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x, position.y, 0.0, 1.0);\n  gl_PointSize = pointDiameter * devicePixelRatio;\n  vColor = pointColor;\n  "+(e?"positionY = position.y;":"")+"\n}\n"},c=12,u=function(e){if(0===e.length)return[];var n=Object(s.g)(e),t=Object(s.j)(n).reverse(),r=[],o=new Set;t.forEach((function(e,n){var l=e.value;if(t[n].comparisonOperator!==i.a.EQUAL)if(0!==n){var c=t[n-1],u=c.value,h=(u+l)/2,d=Object(s.a)(h,t);if(null!=d&&!o.has(c.value)){var f=Object(a.d)(d.color);y=f[0],w=f[1],P=f[2],c.comparisonOperator===i.a.EQUAL&&(c.value,t[n].value),r.push({upper:u,lower:l,color:[y,w,P]}),o.add(c.value)}if(n!==t.length-1){var p=t[n+1].value;if(h=(l+p)/2,null!=(d=Object(s.a)(h,t))&&!o.has(l)){var v=Object(a.d)(d.color);y=v[0],w=v[1],P=v[2],r.push({upper:l,lower:p,color:[y,w,P]}),o.add(e.value)}}else if(h=(l+Number.MIN_SAFE_INTEGER)/2,null!=(d=Object(s.a)(h,t))&&!o.has(l)){var m=Object(a.d)(d.color);y=m[0],w=m[1],P=m[2],r.push({lower:Number.MIN_SAFE_INTEGER,upper:l,color:[y,w,P]})}}else{var g=(Number.MAX_SAFE_INTEGER+l)/2,b=Object(s.a)(g,t);if(null!=b){var x=Object(a.d)(b.color),y=x[0],w=x[1],P=x[2];r.push({upper:Number.MAX_SAFE_INTEGER,lower:l,color:[y,w,P]})}}else{var S=Object(a.d)(t[n].color);y=S[0],w=S[1],P=S[2];r.push({upper:l,lower:l,color:[y,w,P]})}}));for(var l=r[r.length-1];r.length<c;){var u=t[t.length-1].value,h=Number.MIN_SAFE_INTEGER+u/2,d=Object(s.a)(h,t);if(null==d)r.push(l);else{var f=Object(a.d)(d.color),p=f[0],v=f[1],m=f[2];l={lower:Number.MIN_SAFE_INTEGER,upper:u,color:[p,v,m]},r.push(l)}}return r},h="\n#define MAX_NUM_TOTAL_THRESHOLD_BAND "+c+"\n\nstruct Band {\n  float upper;\n  float lower;\n  vec3 color;\n};\n\nvarying vec3 vColor;\nvarying float positionY;\n\nuniform Band thresholdBands[MAX_NUM_TOTAL_THRESHOLD_BAND];\nuniform float yPixelDensity;\n\nvoid main() {\n  // calculate position such that the center is (0, 0) in a region of [-1, 1] x [-1, 1]\n  vec2 pos = 2.0 * gl_PointCoord.xy - 1.0;\n  // r = distance squared from the origin of the point being rendered\n  float r = dot(pos, pos);\n  if (r > 1.0) {\n    discard;\n  }\n  float alpha = 1.0 - smoothstep(0.5, 1.0, sqrt(r));\n\n  for(int i = 0; i < MAX_NUM_TOTAL_THRESHOLD_BAND; i++) {\n    bool isRangeBreached = positionY >= thresholdBands[i].lower && positionY <= thresholdBands[i].upper;\n    bool isEqualsThreshold = thresholdBands[i].lower == thresholdBands[i].upper;\n    bool isEqualsThresholdBreached = positionY == thresholdBands[i].upper;\n\n    if (isRangeBreached || (isEqualsThreshold && isEqualsThresholdBreached)) {\n       gl_FragColor = vec4(thresholdBands[i].color /255.0, alpha);\n       break;\n    } else {\n       gl_FragColor = vec4(vColor, alpha);\n    }\n  }\n}\n",d=0,f=function(e){return 0===(null!=e[0]?e[0].resolution:null)?4:6.25},p=2,v=function(e,n,t){var i=n.filter(o.a).map((function(e){return Object(a.f)(e,e.resolution)})).flat(),r=e.attributes,s=r.position,l=r.pointColor;i.forEach((function(e,n){var i=e[0],r=e[1],o=e[2],a=e[3],c=e[4];s.array[n*p]=t(i),s.array[n*p+1]=r,l.array[3*n]=o,l.array[3*n+1]=a,l.array[3*n+2]=c})),e.setDrawRange(0,i.length),s.needsUpdate=!0,l.needsUpdate=!0},m=function(e){var n=e.toClipSpace,t=e.dataStreams,i=e.minBufferSize,o=e.bufferFactor,s=e.thresholdOptions,c=e.thresholds,d=Math.max(i,Object(a.e)(t)*o),m=new r.a;!function(e,n){e.setAttribute("position",new r.i(new Float32Array(n*p),p)),e.setAttribute("pointColor",new r.i(new Uint8Array(3*n),3,!0))}(m,d),v(m,t,n);var g=s.showColor,b=void 0===g||g,x=new r.g({vertexShader:l(b&&c.length>0),fragmentShader:b&&0!==c.length?h:"\nvarying vec3 vColor;\n\nvoid main() {\n  // calculate position such that the center is (0, 0) in a region of [-1, 1] x [-1, 1]\n  vec2 pos = 2.0 * gl_PointCoord.xy - 1.0;\n  // r = distance squared from the origin of the point being rendered\n  float r = dot(pos, pos);\n  if (r > 1.0) {\n    discard;\n  }\n  float alpha = 1.0 - smoothstep(0.5, 1.0, sqrt(r));\n  gl_FragColor = vec4(vColor, alpha);\n}\n",transparent:!0,uniforms:{pointDiameter:{value:f(t)},devicePixelRatio:{value:window.devicePixelRatio},thresholdBands:{value:u(c)}}}),y=new r.e(m,x);return y.frustumCulled=!1,y},g=function(e,n,t,i){void 0===i&&(i=!0),n.material.uniforms.pointDiameter.value=f(e),n.material.uniforms.devicePixelRatio.value=window.devicePixelRatio,i&&v(n.geometry,e,t)}},1155:function(e,n,t){"use strict";t.d(n,"a",(function(){return c})),t.d(n,"b",(function(){return p})),t.d(n,"c",(function(){return d})),t.d(n,"d",(function(){return m})),t.d(n,"e",(function(){return u})),t.d(n,"f",(function(){return g}));var i=t(1132),r=t(1143),o=t(1139),a=t(1145),s=t(1141),l=function(e){return"\nvarying vec3 vColor;\n"+(e?"varying float positionY;":"")+"\nattribute vec3 pointColor;\nuniform float pointDiameter;\nuniform float devicePixelRatio;\n\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x, position.y, 0.0, 1.0);\n  gl_PointSize = pointDiameter * devicePixelRatio;\n  vColor = pointColor;\n  "+(e?"positionY = position.y;":"")+"\n}\n"},c=12,u=function(e){if(0===e.length)return[];var n=Object(s.g)(e),t=Object(s.j)(n).reverse(),r=[],o=new Set;t.forEach((function(e,n){var l=e.value;if(t[n].comparisonOperator!==i.a.EQUAL)if(0!==n){var c=t[n-1],u=c.value,h=(u+l)/2,d=Object(s.a)(h,t);if(null!=d&&!o.has(c.value)){var f=Object(a.d)(d.color);y=f[0],w=f[1],P=f[2],c.comparisonOperator===i.a.EQUAL&&(c.value,t[n].value),r.push({upper:u,lower:l,color:[y,w,P]}),o.add(c.value)}if(n!==t.length-1){var p=t[n+1].value;if(h=(l+p)/2,null!=(d=Object(s.a)(h,t))&&!o.has(l)){var v=Object(a.d)(d.color);y=v[0],w=v[1],P=v[2],r.push({upper:l,lower:p,color:[y,w,P]}),o.add(e.value)}}else if(h=(l+Number.MIN_SAFE_INTEGER)/2,null!=(d=Object(s.a)(h,t))&&!o.has(l)){var m=Object(a.d)(d.color);y=m[0],w=m[1],P=m[2],r.push({lower:Number.MIN_SAFE_INTEGER,upper:l,color:[y,w,P]})}}else{var g=(Number.MAX_SAFE_INTEGER+l)/2,b=Object(s.a)(g,t);if(null!=b){var x=Object(a.d)(b.color),y=x[0],w=x[1],P=x[2];r.push({upper:Number.MAX_SAFE_INTEGER,lower:l,color:[y,w,P]})}}else{var S=Object(a.d)(t[n].color);y=S[0],w=S[1],P=S[2];r.push({upper:l,lower:l,color:[y,w,P]})}}));for(var l=r[r.length-1];r.length<c;){var u=t[t.length-1].value,h=Number.MIN_SAFE_INTEGER+u/2,d=Object(s.a)(h,t);if(null==d)r.push(l);else{var f=Object(a.d)(d.color),p=f[0],v=f[1],m=f[2];l={lower:Number.MIN_SAFE_INTEGER,upper:u,color:[p,v,m]},r.push(l)}}return r},h="\n#define MAX_NUM_TOTAL_THRESHOLD_BAND "+c+"\n\nstruct Band {\n  float upper;\n  float lower;\n  vec3 color;\n};\n\nvarying vec3 vColor;\nvarying float positionY;\n\nuniform Band thresholdBands[MAX_NUM_TOTAL_THRESHOLD_BAND];\nuniform float yPixelDensity;\n\nvoid main() {\n  // calculate position such that the center is (0, 0) in a region of [-1, 1] x [-1, 1]\n  vec2 pos = 2.0 * gl_PointCoord.xy - 1.0;\n  // r = distance squared from the origin of the point being rendered\n  float r = dot(pos, pos);\n  if (r > 1.0) {\n    discard;\n  }\n  float alpha = 1.0 - smoothstep(0.5, 1.0, sqrt(r));\n\n  for(int i = 0; i < MAX_NUM_TOTAL_THRESHOLD_BAND; i++) {\n    bool isRangeBreached = positionY >= thresholdBands[i].lower && positionY <= thresholdBands[i].upper;\n    bool isEqualsThreshold = thresholdBands[i].lower == thresholdBands[i].upper;\n    bool isEqualsThresholdBreached = positionY == thresholdBands[i].upper;\n\n    if (isRangeBreached || (isEqualsThreshold && isEqualsThresholdBreached)) {\n       gl_FragColor = vec4(thresholdBands[i].color /255.0, alpha);\n       break;\n    } else {\n       gl_FragColor = vec4(vColor, alpha);\n    }\n  }\n}\n",d=0,f=function(e){return 0===(null!=e[0]?e[0].resolution:null)?4:6.25},p=2,v=function(e,n,t){var i=n.filter(o.a).map((function(e){return Object(a.f)(e,e.resolution)})).flat(),r=e.attributes,s=r.position,l=r.pointColor;i.forEach((function(e,n){var i=e[0],r=e[1],o=e[2],a=e[3],c=e[4];s.array[n*p]=t(i),s.array[n*p+1]=r,l.array[3*n]=o,l.array[3*n+1]=a,l.array[3*n+2]=c})),e.setDrawRange(0,i.length),s.needsUpdate=!0,l.needsUpdate=!0},m=function(e){var n=e.toClipSpace,t=e.dataStreams,i=e.minBufferSize,o=e.bufferFactor,s=e.thresholdOptions,c=e.thresholds,d=Math.max(i,Object(a.e)(t)*o),m=new r.a;!function(e,n){e.setAttribute("position",new r.i(new Float32Array(n*p),p)),e.setAttribute("pointColor",new r.i(new Uint8Array(3*n),3,!0))}(m,d),v(m,t,n);var g=s.showColor,b=void 0===g||g,x=new r.g({vertexShader:l(b&&c.length>0),fragmentShader:b&&0!==c.length?h:"\nvarying vec3 vColor;\n\nvoid main() {\n  // calculate position such that the center is (0, 0) in a region of [-1, 1] x [-1, 1]\n  vec2 pos = 2.0 * gl_PointCoord.xy - 1.0;\n  // r = distance squared from the origin of the point being rendered\n  float r = dot(pos, pos);\n  if (r > 1.0) {\n    discard;\n  }\n  float alpha = 1.0 - smoothstep(0.5, 1.0, sqrt(r));\n  gl_FragColor = vec4(vColor, alpha);\n}\n",transparent:!0,uniforms:{pointDiameter:{value:f(t)},devicePixelRatio:{value:window.devicePixelRatio},thresholdBands:{value:u(c)}}}),y=new r.e(m,x);return y.frustumCulled=!1,y},g=function(e,n,t,i){void 0===i&&(i=!0),n.material.uniforms.pointDiameter.value=f(e),n.material.uniforms.devicePixelRatio.value=window.devicePixelRatio,i&&v(n.geometry,e,t)}},1166:function(e,n,t){"use strict";t.d(n,"a",(function(){return r})),t.d(n,"b",(function(){return o})),t.d(n,"c",(function(){return a}));var i=t(99),r={widgetId:"fake-id",viewPort:{start:new Date(1995,0,0,0),end:new Date(2020,1,0,0),yMin:0,yMax:1e4},size:{width:475,height:350,marginLeft:50,marginRight:40,marginTop:24,marginBottom:30},movement:{enableXScroll:!0,enableYScroll:!1,zoomMax:1/0,zoomMin:1e-5},layout:{xGridVisible:!1,yGridVisible:!0,xTicksVisible:!0,yTicksVisible:!0},scale:{xScaleType:i.b.TimeSeries,yScaleType:i.b.Linear,xScaleSide:"bottom",yScaleSide:"left"},dataStreams:[],legend:{position:i.a.BOTTOM,width:170}},o={showColor:!0},a={showColor:!1}},1168:function(e,n,t){"use strict";t.d(n,"a",(function(){return p})),t.d(n,"b",(function(){return v}));var i=t(1142),r=t(1137),o=t(1154),a=t(1144),s=t(1140),l=function(e){return"\nprecision highp float;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float width;\nuniform float xPixelDensity;\nuniform float yPixelDensity;\nattribute vec2 currPoint;\nattribute vec2 nextPoint;\nattribute vec2 position;\nattribute vec3 segmentColor;\nvarying vec3 vColor;\n"+(e?"varying float yPositionPx;":"")+"\n\n// line shader using instanced lines\n// https://wwwtyro.net/2019/11/18/instanced-lines.html for information on this approach\nvoid main() {\n  // Convert the points to pixel coordinates - otherwise out basis vectors won't be perpendicular when\n  // rasterized to the screen.\n  vec2 currPointPx = vec2(currPoint.x / xPixelDensity, currPoint.y / yPixelDensity);\n  vec2 nextPointPx = vec2(nextPoint.x / xPixelDensity, nextPoint.y / yPixelDensity);\n\n  // create the basis vectors of a coordinate space where the x axis is parallel with\n  // the path between currPoint and nextPoint, and the y axis is perpendicular to the\n  // path between currPoint and nextPoint\n  vec2 xBasis = nextPointPx - currPointPx;\n  vec2 yBasis = normalize(vec2(-xBasis.y, xBasis.x));\n\n  // project the instance segment along the basis vectors\n  vec2 positionPx = currPointPx + xBasis * position.x + yBasis * width * position.y;\n\n  // Convert from pixel coordinates back to model space\n  vec2 positionModel = vec2(positionPx.x * xPixelDensity, positionPx.y * yPixelDensity);\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(positionModel, 0.0, 1.0);\n  vColor = segmentColor;\n  "+(e?"yPositionPx = positionPx.y;":"")+"\n}\n"},c="\n// This file is only being used when we have threshold bands\n// that will break the line segments into different color\n#define MAX_NUM_TOTAL_THRESHOLD_BAND "+o.a+"\n\nprecision highp float;\nstruct Band {\n  float upper;\n  float lower;\n  vec3 color;\n};\n\nvarying vec3 vColor;\nvarying float yPositionPx;\nuniform float yPixelDensity;\nuniform Band thresholdBands[MAX_NUM_TOTAL_THRESHOLD_BAND];\n\n// Fills in triangles which make up a line segment, with the corresponding color\nvoid main() {\n  for(int i = 0; i < MAX_NUM_TOTAL_THRESHOLD_BAND; i++) {\n    bool isRangeBreached = yPositionPx > thresholdBands[i].lower / yPixelDensity\n      && yPositionPx < thresholdBands[i].upper / yPixelDensity;\n    bool isEqualsThreshold = thresholdBands[i].lower == thresholdBands[i].upper;\n    bool isEqualsThresholdBreached = yPositionPx == thresholdBands[i].upper;\n\n    if (isRangeBreached || (isEqualsThreshold && isEqualsThresholdBreached)) {\n       gl_FragColor = vec4(thresholdBands[i].color / 255.0, 1.0);\n       break;\n    } else {\n       gl_FragColor = vec4(vColor, 1.0);\n    }\n  }\n}\n",u=function(e){var n=e.viewPort,t=n.end,i=n.start,r=n.yMax,o=n.yMin,a=e.toClipSpace,s=e.size,l=s.width,c=s.height;return{x:Math.abs((a(t.getTime())-a(i.getTime()))/l),y:Math.abs((r-o)/c)}},h=function(e,n,t){var i=e.filter(r.a).map((function(e){return Object(a.f)(e,e.resolution)}));n.count=function(e){return e.reduce((function(e,n){return e+Math.max(n.length,0)}),0)}(i);var o=n.geometry.attributes,s=o.currPoint,l=o.nextPoint,c=o.segmentColor,u=0,h=0;i.forEach((function(e){e.forEach((function(n,i){var r=i===e.length-1?n:e[i+1],o=n[0],a=n[1],d=n[2],f=n[3],p=n[4],v=r[0],m=r[1];s.array[u]=t(o),s.array[u+1]=a,l.array[u]=t(v),l.array[u+1]=m,c.array[h]=d,c.array[h+1]=f,c.array[h+2]=p,h+=3,u+=2}))})),s.needsUpdate=!0,l.needsUpdate=!0,c.needsUpdate=!0},d=[[0,-.5],[1,-.5],[1,.5],[0,-.5],[1,.5],[0,.5]],f=function(e){var n=e.viewPort,t=e.dataStreams,r=e.chartSize,s=e.minBufferSize,f=e.bufferFactor,p=e.toClipSpace,v=e.thresholdOptions,m=e.thresholds,g=new i.c,b=Math.max(s,Object(a.e)(t)*f);!function(e,n){e.setAttribute("position",new i.i(new Float32Array(d.flat()),2)),e.setAttribute("currPoint",new i.k(new Float32Array(2*n),2,!1)),e.setAttribute("nextPoint",new i.k(new Float32Array(2*n),2,!1)),e.setAttribute("segmentColor",new i.k(new Uint8Array(3*n),3,!0))}(g,b);var x=u({viewPort:n,toClipSpace:p,size:r}),y=x.x,w=x.y,P=v.showColor,S=void 0===P||P,O=new i.f({vertexShader:l(S&&m.length>0),fragmentShader:S&&0!==m.length?c:"\nprecision highp float;\nvarying vec3 vColor;\n\n// Fills in triangles which make up a line segment, with the corresponding color\nvoid main() {\n  gl_FragColor = vec4(vColor, 1.0);\n}\n",side:i.b,transparent:!0,uniforms:{width:{value:1.5},xPixelDensity:{value:y},yPixelDensity:{value:w},thresholdBands:{value:Object(o.e)(m)}}}),C=new i.j(g,O,b);return C.frustumCulled=!1,h(t,C,p),C},p=function(e){var n=e.dataStreams,t=e.chartSize,r=e.container,l=e.viewPort,c=e.minBufferSize,u=e.bufferFactor,h=e.onUpdate,d=e.thresholdOptions,p=e.thresholds,v=new i.l,m=Object(a.a)(l),g=Object(s.g)(p),b=[];return b[1]=f({toClipSpace:m,chartSize:t,dataStreams:n,viewPort:l,minBufferSize:c,bufferFactor:u,thresholdOptions:d,thresholds:g}),b[o.c]=Object(o.d)({dataStreams:n,minBufferSize:c,bufferFactor:u,toClipSpace:m,thresholdOptions:d,thresholds:g}),b.forEach((function(e){return v.add(e)})),Object(a.c)({scene:v,viewPort:l,container:r,toClipSpace:m,onUpdate:h})},v=function(e){var n=e.scene,t=e.dataStreams,i=e.chartSize,r=e.container,s=e.viewPort,l=e.hasDataChanged,c=e.bufferFactor,d=e.minBufferSize,f=e.onUpdate,v=e.thresholdOptions,m=e.hasAnnotationChanged,g=e.thresholds,b=n.scene.children[1],x=n.scene.children[o.c];return function(e){return e.geometry.attributes.position.array.length/o.b}(x)<Object(a.e)(t)||Object(a.b)(s,n.toClipSpace)||m?p({dataStreams:t,chartSize:i,container:r,viewPort:s,minBufferSize:d,bufferFactor:c,onUpdate:f,thresholdOptions:v,thresholds:g}):(function(e){var n=e.chartSize,t=e.toClipSpace,i=e.lines,r=e.dataStreams,o=e.viewPort,a=e.hasDataChanged,s=u({viewPort:o,toClipSpace:t,size:n}),l=s.x,c=s.y;i.material.uniforms.xPixelDensity.value=l,i.material.uniforms.yPixelDensity.value=c,a&&h(r,i,t)}({lines:b,dataStreams:t,chartSize:i,viewPort:s,hasDataChanged:l,toClipSpace:n.toClipSpace}),Object(o.f)(t,x,n.toClipSpace,l),n)}},1169:function(e,n,t){"use strict";t.d(n,"a",(function(){return r})),t.d(n,"b",(function(){return o})),t.d(n,"c",(function(){return a}));var i=t(1133),r={widgetId:"fake-id",viewPort:{start:new Date(1995,0,0,0),end:new Date(2020,1,0,0),yMin:0,yMax:1e4},size:{width:475,height:350,marginLeft:50,marginRight:40,marginTop:24,marginBottom:30},movement:{enableXScroll:!0,enableYScroll:!1,zoomMax:1/0,zoomMin:1e-5},layout:{xGridVisible:!1,yGridVisible:!0,xTicksVisible:!0,yTicksVisible:!0},scale:{xScaleType:i.b.TimeSeries,yScaleType:i.b.Linear,xScaleSide:"bottom",yScaleSide:"left"},dataStreams:[],legend:{position:i.a.BOTTOM,width:170}},o={showColor:!0},a={showColor:!1}},1171:function(e,n,t){"use strict";t.d(n,"a",(function(){return p})),t.d(n,"b",(function(){return v}));var i=t(1143),r=t(1139),o=t(1155),a=t(1145),s=t(1141),l=function(e){return"\nprecision highp float;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float width;\nuniform float xPixelDensity;\nuniform float yPixelDensity;\nattribute vec2 currPoint;\nattribute vec2 nextPoint;\nattribute vec2 position;\nattribute vec3 segmentColor;\nvarying vec3 vColor;\n"+(e?"varying float yPositionPx;":"")+"\n\n// line shader using instanced lines\n// https://wwwtyro.net/2019/11/18/instanced-lines.html for information on this approach\nvoid main() {\n  // Convert the points to pixel coordinates - otherwise out basis vectors won't be perpendicular when\n  // rasterized to the screen.\n  vec2 currPointPx = vec2(currPoint.x / xPixelDensity, currPoint.y / yPixelDensity);\n  vec2 nextPointPx = vec2(nextPoint.x / xPixelDensity, nextPoint.y / yPixelDensity);\n\n  // create the basis vectors of a coordinate space where the x axis is parallel with\n  // the path between currPoint and nextPoint, and the y axis is perpendicular to the\n  // path between currPoint and nextPoint\n  vec2 xBasis = nextPointPx - currPointPx;\n  vec2 yBasis = normalize(vec2(-xBasis.y, xBasis.x));\n\n  // project the instance segment along the basis vectors\n  vec2 positionPx = currPointPx + xBasis * position.x + yBasis * width * position.y;\n\n  // Convert from pixel coordinates back to model space\n  vec2 positionModel = vec2(positionPx.x * xPixelDensity, positionPx.y * yPixelDensity);\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(positionModel, 0.0, 1.0);\n  vColor = segmentColor;\n  "+(e?"yPositionPx = positionPx.y;":"")+"\n}\n"},c="\n// This file is only being used when we have threshold bands\n// that will break the line segments into different color\n#define MAX_NUM_TOTAL_THRESHOLD_BAND "+o.a+"\n\nprecision highp float;\nstruct Band {\n  float upper;\n  float lower;\n  vec3 color;\n};\n\nvarying vec3 vColor;\nvarying float yPositionPx;\nuniform float yPixelDensity;\nuniform Band thresholdBands[MAX_NUM_TOTAL_THRESHOLD_BAND];\n\n// Fills in triangles which make up a line segment, with the corresponding color\nvoid main() {\n  for(int i = 0; i < MAX_NUM_TOTAL_THRESHOLD_BAND; i++) {\n    bool isRangeBreached = yPositionPx > thresholdBands[i].lower / yPixelDensity\n      && yPositionPx < thresholdBands[i].upper / yPixelDensity;\n    bool isEqualsThreshold = thresholdBands[i].lower == thresholdBands[i].upper;\n    bool isEqualsThresholdBreached = yPositionPx == thresholdBands[i].upper;\n\n    if (isRangeBreached || (isEqualsThreshold && isEqualsThresholdBreached)) {\n       gl_FragColor = vec4(thresholdBands[i].color / 255.0, 1.0);\n       break;\n    } else {\n       gl_FragColor = vec4(vColor, 1.0);\n    }\n  }\n}\n",u=function(e){var n=e.viewPort,t=n.end,i=n.start,r=n.yMax,o=n.yMin,a=e.toClipSpace,s=e.size,l=s.width,c=s.height;return{x:Math.abs((a(t.getTime())-a(i.getTime()))/l),y:Math.abs((r-o)/c)}},h=function(e,n,t){var i=e.filter(r.a).map((function(e){return Object(a.f)(e,e.resolution)}));n.count=function(e){return e.reduce((function(e,n){return e+Math.max(n.length,0)}),0)}(i);var o=n.geometry.attributes,s=o.currPoint,l=o.nextPoint,c=o.segmentColor,u=0,h=0;i.forEach((function(e){e.forEach((function(n,i){var r=i===e.length-1?n:e[i+1],o=n[0],a=n[1],d=n[2],f=n[3],p=n[4],v=r[0],m=r[1];s.array[u]=t(o),s.array[u+1]=a,l.array[u]=t(v),l.array[u+1]=m,c.array[h]=d,c.array[h+1]=f,c.array[h+2]=p,h+=3,u+=2}))})),s.needsUpdate=!0,l.needsUpdate=!0,c.needsUpdate=!0},d=[[0,-.5],[1,-.5],[1,.5],[0,-.5],[1,.5],[0,.5]],f=function(e){var n=e.viewPort,t=e.dataStreams,r=e.chartSize,s=e.minBufferSize,f=e.bufferFactor,p=e.toClipSpace,v=e.thresholdOptions,m=e.thresholds,g=new i.c,b=Math.max(s,Object(a.e)(t)*f);!function(e,n){e.setAttribute("position",new i.i(new Float32Array(d.flat()),2)),e.setAttribute("currPoint",new i.k(new Float32Array(2*n),2,!1)),e.setAttribute("nextPoint",new i.k(new Float32Array(2*n),2,!1)),e.setAttribute("segmentColor",new i.k(new Uint8Array(3*n),3,!0))}(g,b);var x=u({viewPort:n,toClipSpace:p,size:r}),y=x.x,w=x.y,P=v.showColor,S=void 0===P||P,O=new i.f({vertexShader:l(S&&m.length>0),fragmentShader:S&&0!==m.length?c:"\nprecision highp float;\nvarying vec3 vColor;\n\n// Fills in triangles which make up a line segment, with the corresponding color\nvoid main() {\n  gl_FragColor = vec4(vColor, 1.0);\n}\n",side:i.b,transparent:!0,uniforms:{width:{value:1.5},xPixelDensity:{value:y},yPixelDensity:{value:w},thresholdBands:{value:Object(o.e)(m)}}}),C=new i.j(g,O,b);return C.frustumCulled=!1,h(t,C,p),C},p=function(e){var n=e.dataStreams,t=e.chartSize,r=e.container,l=e.viewPort,c=e.minBufferSize,u=e.bufferFactor,h=e.onUpdate,d=e.thresholdOptions,p=e.thresholds,v=new i.l,m=Object(a.a)(l),g=Object(s.g)(p),b=[];return b[1]=f({toClipSpace:m,chartSize:t,dataStreams:n,viewPort:l,minBufferSize:c,bufferFactor:u,thresholdOptions:d,thresholds:g}),b[o.c]=Object(o.d)({dataStreams:n,minBufferSize:c,bufferFactor:u,toClipSpace:m,thresholdOptions:d,thresholds:g}),b.forEach((function(e){return v.add(e)})),Object(a.c)({scene:v,viewPort:l,container:r,toClipSpace:m,onUpdate:h})},v=function(e){var n=e.scene,t=e.dataStreams,i=e.chartSize,r=e.container,s=e.viewPort,l=e.hasDataChanged,c=e.bufferFactor,d=e.minBufferSize,f=e.onUpdate,v=e.thresholdOptions,m=e.hasAnnotationChanged,g=e.thresholds,b=n.scene.children[1],x=n.scene.children[o.c];return function(e){return e.geometry.attributes.position.array.length/o.b}(x)<Object(a.e)(t)||Object(a.b)(s,n.toClipSpace)||m?p({dataStreams:t,chartSize:i,container:r,viewPort:s,minBufferSize:d,bufferFactor:c,onUpdate:f,thresholdOptions:v,thresholds:g}):(function(e){var n=e.chartSize,t=e.toClipSpace,i=e.lines,r=e.dataStreams,o=e.viewPort,a=e.hasDataChanged,s=u({viewPort:o,toClipSpace:t,size:n}),l=s.x,c=s.y;i.material.uniforms.xPixelDensity.value=l,i.material.uniforms.yPixelDensity.value=c,a&&h(r,i,t)}({lines:b,dataStreams:t,chartSize:i,viewPort:s,hasDataChanged:l,toClipSpace:n.toClipSpace}),Object(o.f)(t,x,n.toClipSpace,l),n)}},883:function(e,n,t){"use strict";t.r(n),t.d(n,"monitor_line_chart",(function(){return c}));var i=t(60),r=(t(42),t(68)),o=(t(99),t(69),t(1136),t(1166)),a=(t(1142),t(1137),t(1154),t(1159),t(1160),t(1150),t(1144),t(1152),t(1146),t(1140),t(1168)),s=r.c.DATA_ALIGNMENT,l=function(e){return Object(i.h)("monitor-tooltip",Object.assign({},e,{visualizesAlarms:!1,supportString:!1,dataAlignment:s.EITHER}))},c=function(){function e(e){Object(i.i)(this,e),this.gestures=!0,this.isEditing=!1,this.bufferFactor=2,this.minBufferSize=1e3}return e.prototype.render=function(){var e=this;return Object(i.h)("monitor-size-provider",{size:this.size,renderFunc:function(n){return Object(i.h)("monitor-webgl-base-chart",{axis:e.axis,alarms:e.alarms,gestures:e.gestures,configId:e.widgetId,requestData:e.requestData,legend:e.legend,annotations:e.annotations,trends:e.trends,updateChartScene:a.b,createChartScene:a.a,size:Object.assign(Object.assign(Object.assign({},o.a.size),e.size),n),dataStreams:e.dataStreams,viewPort:e.viewPort,minBufferSize:e.minBufferSize,bufferFactor:e.bufferFactor,isEditing:e.isEditing,tooltip:l,supportString:!1,visualizesAlarms:!1,messageOverrides:e.messageOverrides})}})},e}()}}]);