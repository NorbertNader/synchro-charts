{"version":3,"sources":["../node_modules/@amzn/bp-components/dist/esm-es5/getVisibleData-38130c2d.js","../node_modules/@amzn/bp-components/dist/esm-es5/number-1681647b.js","../node_modules/@amzn/bp-components/dist/esm-es5/monitor-latest-value.entry.js","../node_modules/@amzn/bp-components/dist/esm-es5/index-085eab52.js"],"names":["pointBisector","bisector","p","x","getVisibleData","data","_a","includeBoundaryPoints","start","end","length","startIndex","Math","max","left","endIndex","min","right","slice","precision","num","digits","toString","split","integer","fractional","Number","parseFloat","toPrecision","MonitorLatestValue","hostRef","registerInstance","this","errorMap","getLatestValue","dataStream","config","idx","viewPort","target","point","isInViewPort","undefined","prototype","render","latestPoint","Object","keys","h","class","y","dataStreamInfo","unit","style","ascending","a","b","NaN","compare","f","d","lo","hi","mid","bisectRight","e10","sqrt","e5","e2","ticks","stop","count","reverse","n","step","i","tickIncrement","isFinite","ceil","floor","Array","power","log","LN10","error","pow","tickStep","step0","abs","step1"],"mappings":"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","file":"static/js/stencil-monitor-latest-value-entry-js.ed2dee26.chunk.js","sourcesContent":["import { b as bisector } from './index-085eab52.js';\n// By doing the mapping to a date within the bisector\n// we eliminate the need to iterate over the entire data.\n// (As opposed to mapping entire data to an array of dates)\nvar pointBisector = bisector(function (p) { return p.x; });\n/**\n * Get Visible Data\n *\n * Returns the data points which are required for the chart to correctly render.\n * This assumes linear interpolation between points\n * TODO(btd): Support other interpolation methods\n *\n * NOTE: It's possible to have data not in the viewport which is required for the chart to render\n * it's fully visualization correctly. For Instance, even if a point isn't visible in the viewport, it may\n * be used within interpolation to calculate a path between the points which is within the viewport.\n *\n * Different interpolation methods need larger amount of context around the viewport to correctly render\n * the chart visualization.\n */\nvar getVisibleData = function (data, _a, \n// Whether we want to include a single point to the right, and to the left of the provide viewport.\n// This is useful when rendering lines since you need to connect a point to a point outside of the viewport\n// to fully render the data correctly.\nincludeBoundaryPoints) {\n    var start = _a.start, end = _a.end;\n    if (includeBoundaryPoints === void 0) { includeBoundaryPoints = true; }\n    // If there is no data\n    if (data.length === 0) {\n        return [];\n    }\n    // If all data is before the view port\n    if (start > data[data.length - 1].x) {\n        return [];\n    }\n    // If all data is after the view port\n    if (end < data[0].x) {\n        return [];\n    }\n    // Otherwise return all the data within the viewport, plus an additional single data point that falls outside of\n    // the viewport in either direction.\n    var startIndex = Math.max(pointBisector.left(data, start) - (includeBoundaryPoints ? 1 : 0), 0);\n    var endIndex = Math.min(pointBisector.right(data, end) - (includeBoundaryPoints ? 0 : 1), data.length - 1);\n    return data.slice(startIndex, endIndex + 1);\n};\nexport { getVisibleData as g, pointBisector as p };\n","var MAX_PRECISION = 3;\n/**\n * Computes the siginificant digits for a given number to the max precision\n */\nvar precision = function (num) {\n    var digits = num.toString();\n    var _a = digits.split('.'), integer = _a[0], fractional = _a[1];\n    if (num === 0)\n        return 0;\n    if (fractional == null) {\n        return num;\n    }\n    if (integer.length >= MAX_PRECISION) {\n        /**\n         * In math, any number greater than 4 should be rounded\n         */\n        var shouldRound = Number(fractional[0]) > 4;\n        return shouldRound ? Number(integer) + 1 : Number(integer);\n    }\n    return Number(Number.parseFloat(digits).toPrecision(MAX_PRECISION));\n};\nexport { precision as p };\n","import { r as registerInstance, h } from './index-326b73e4.js';\nimport './index-085eab52.js';\nimport { p as pointBisector } from './getVisibleData-38130c2d.js';\nimport { p as precision } from './number-1681647b.js';\nvar monitorLatestValueCss = \".latest-value{display:-ms-flexbox;display:flex;text-align:right;-ms-flex-direction:column;flex-direction:column}.value{font-size:var(--font-size-3);font-weight:var(--font-weight-regular);line-height:var(--line-height-3)}.unit{font-size:var(--font-size-1);font-weight:var(--font-weight-normal);color:var(--error-badge-font-color)}\";\nvar isInViewPort = function (point, config) { return point.x >= config.viewPort.start && point.x <= config.viewPort.end; };\nvar MonitorLatestValue = /** @class */ (function () {\n    function MonitorLatestValue(hostRef) {\n        registerInstance(this, hostRef);\n        this.errorMap = {};\n        this.getLatestValue = function (dataStream, config) {\n            if (!dataStream || !dataStream.data.length)\n                return undefined;\n            var idx = pointBisector.left(dataStream.data, config.viewPort.end);\n            var target = dataStream.data[idx - 1];\n            /**\n             * We only want data points that are between our start and end dates\n             */\n            return target && isInViewPort(target, config) ? target : undefined;\n        };\n    }\n    MonitorLatestValue.prototype.render = function () {\n        var dataStream = this.data[0];\n        var latestPoint = this.getLatestValue(dataStream, this.config);\n        var hasError = Object.keys(this.errorMap).length > 0;\n        if (hasError || !latestPoint)\n            return undefined;\n        return (h(\"div\", { class: \"latest-value\" }, h(\"span\", { class: \"value\", \"data-testid\": \"latest-value\" }, precision(latestPoint.y)), ' ', this.config.dataStreamInfo[0] && this.config.dataStreamInfo[0].unit && (h(\"span\", { class: \"unit\" }, \"(\", this.config.dataStreamInfo[0].unit, \")\"))));\n    };\n    return MonitorLatestValue;\n}());\nMonitorLatestValue.style = monitorLatestValueCss;\nexport { MonitorLatestValue as monitor_latest_value };\n","function ascending(a, b) {\n    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\nfunction bisector(compare) {\n    if (compare.length === 1)\n        compare = ascendingComparator(compare);\n    return {\n        left: function (a, x, lo, hi) {\n            if (lo == null)\n                lo = 0;\n            if (hi == null)\n                hi = a.length;\n            while (lo < hi) {\n                var mid = lo + hi >>> 1;\n                if (compare(a[mid], x) < 0)\n                    lo = mid + 1;\n                else\n                    hi = mid;\n            }\n            return lo;\n        },\n        right: function (a, x, lo, hi) {\n            if (lo == null)\n                lo = 0;\n            if (hi == null)\n                hi = a.length;\n            while (lo < hi) {\n                var mid = lo + hi >>> 1;\n                if (compare(a[mid], x) > 0)\n                    hi = mid;\n                else\n                    lo = mid + 1;\n            }\n            return lo;\n        }\n    };\n}\nfunction ascendingComparator(f) {\n    return function (d, x) {\n        return ascending(f(d), x);\n    };\n}\nvar ascendingBisect = bisector(ascending);\nvar bisectRight = ascendingBisect.right;\nvar e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);\nfunction ticks(start, stop, count) {\n    var reverse, i = -1, n, ticks, step;\n    stop = +stop, start = +start, count = +count;\n    if (start === stop && count > 0)\n        return [start];\n    if (reverse = stop < start)\n        n = start, start = stop, stop = n;\n    if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step))\n        return [];\n    if (step > 0) {\n        start = Math.ceil(start / step);\n        stop = Math.floor(stop / step);\n        ticks = new Array(n = Math.ceil(stop - start + 1));\n        while (++i < n)\n            ticks[i] = (start + i) * step;\n    }\n    else {\n        start = Math.floor(start * step);\n        stop = Math.ceil(stop * step);\n        ticks = new Array(n = Math.ceil(start - stop + 1));\n        while (++i < n)\n            ticks[i] = (start - i) / step;\n    }\n    if (reverse)\n        ticks.reverse();\n    return ticks;\n}\nfunction tickIncrement(start, stop, count) {\n    var step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log(step) / Math.LN10), error = step / Math.pow(10, power);\n    return power >= 0\n        ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)\n        : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);\n}\nfunction tickStep(start, stop, count) {\n    var step0 = Math.abs(stop - start) / Math.max(0, count), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;\n    if (error >= e10)\n        step1 *= 10;\n    else if (error >= e5)\n        step1 *= 5;\n    else if (error >= e2)\n        step1 *= 2;\n    return stop < start ? -step1 : step1;\n}\nexport { bisectRight as a, bisector as b, ticks as c, tickIncrement as d, tickStep as t };\n"],"sourceRoot":""}