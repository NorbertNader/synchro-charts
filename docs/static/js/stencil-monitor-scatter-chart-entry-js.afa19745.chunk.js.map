{"version":3,"sources":["../node_modules/@amzn/bp-components/dist/esm-es5/monitor-scatter-chart.entry.js","../node_modules/@amzn/bp-components/dist/esm-es5/constants-2dc21ff9.js","../node_modules/@amzn/bp-components/dist/esm-es5/time-cc688558.js","../node_modules/@amzn/bp-components/dist/esm-es5/chartDefaults-5713566e.js","../node_modules/@amzn/bp-components/dist/esm-es5/clipSpaceConversion-2f416caa.js","../node_modules/@amzn/bp-components/dist/esm-es5/pointMesh-44019046.js"],"names":["chartScene","_a","dataStreams","dataStreamInfo","container","chartSize","viewPort","minBufferSize","bufferFactor","scene","Scene","toClipSpace","clipSpaceConversion","meshList","POINT_MESH_INDEX","pointMesh","forEach","mesh","add","constructChartScene","updateChartScene","hasDataChanged","thresholds","points","children","geometry","attributes","position","array","length","NUM_POSITION_COMPONENTS","maxDataPointsRendered","numDataPoints","needsNewClipSpace","updatePointMesh","MonitorScatterChart","hostRef","registerInstance","this","isLoading","isEditing","isFetching","errorMap","prototype","render","_this","h","size","config","renderFunc","rect","data","yRange","configId","id","legend","annotations","createChartScene","Object","assign","DEFAULT_CHART_CONFIG","ScaleType","LEGEND_POSITION","SECOND_IN_MS","MINUTE_IN_MS","HOUR_IN_MS","DAY_IN_MS","MONTH_IN_MS","YEAR_IN_MS","convertMS","milliseconds","Error","seconds","Math","floor","minute","hour","day","displayDate","date","resolution","start","end","viewPortDurationMS","getTime","toLocaleString","second","hour12","month","year","Date","yMin","yMax","width","height","marginLeft","marginRight","marginTop","marginBottom","movement","enableXScroll","enableYScroll","zoomMax","Infinity","zoomMin","layout","xGridVisible","yGridVisible","xTicksVisible","yTicksVisible","scale","xScaleType","TimeSeries","yScaleType","Linear","xScaleSide","yScaleSide","BOTTOM","durationMS","anchorMS","granularityMS","granularity","t","isDateOutOfBounds","abs","pow","isOutOfBounds","distanceMS","distanceClipSpace","pointDiameter","updateGeometry","allVertices","map","stream","info","find","vertices","flat","pointColor","i","x","y","r","g","b","setDrawRange","needsUpdate","bufferSize","max","BufferGeometry","setAttribute","BufferAttribute","Float32Array","Uint8Array","initializeGeometry","material","ShaderMaterial","vertexShader","fragmentShader","transparent","uniforms","value","devicePixelRatio","window","Points","frustumCulled"],"mappings":"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","file":"static/js/stencil-monitor-scatter-chart-entry-js.afa19745.chunk.js","sourcesContent":["import { r as registerInstance, h } from './index-326b73e4.js';\nimport './types-ef93b8eb.js';\nimport './constants-2dc21ff9.js';\nimport './time-cc688558.js';\nimport './_commonjsHelpers-17042db9.js';\nimport { D as DEFAULT_CHART_CONFIG } from './chartDefaults-5713566e.js';\nimport { e as Scene, d as constructChartScene, n as numDataPoints } from './utils-ef59b734.js';\nimport { P as POINT_MESH_INDEX, p as pointMesh, N as NUM_POSITION_COMPONENTS, u as updatePointMesh } from './pointMesh-44019046.js';\nimport './v4-1d709f5b.js';\nimport './index-085eab52.js';\nimport './predicates-4851c065.js';\nimport { c as clipSpaceConversion, n as needsNewClipSpace } from './clipSpaceConversion-2f416caa.js';\nvar chartScene = function (_a) {\n    var dataStreams = _a.dataStreams, dataStreamInfo = _a.dataStreamInfo, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    chartSize = _a.chartSize, container = _a.container, viewPort = _a.viewPort, minBufferSize = _a.minBufferSize, bufferFactor = _a.bufferFactor;\n    var scene = new Scene();\n    var toClipSpace = clipSpaceConversion(viewPort);\n    // Create and add meshes to the chart scene\n    var meshList = [];\n    meshList[POINT_MESH_INDEX] = pointMesh({\n        dataStreams: dataStreams,\n        dataStreamInfo: dataStreamInfo,\n        minBufferSize: minBufferSize,\n        bufferFactor: bufferFactor,\n        toClipSpace: toClipSpace,\n    });\n    meshList.forEach(function (mesh) { return scene.add(mesh); });\n    return constructChartScene({ scene: scene, viewPort: viewPort, container: container, toClipSpace: toClipSpace });\n};\nvar maxDataPointsRendered = function (points) { return points.geometry.attributes.position.array.length / NUM_POSITION_COMPONENTS; };\nvar updateChartScene = function (_a) {\n    var scene = _a.scene, dataStreams = _a.dataStreams, chartSize = _a.chartSize, dataStreamInfo = _a.dataStreamInfo, container = _a.container, viewPort = _a.viewPort, hasDataChanged = _a.hasDataChanged, bufferFactor = _a.bufferFactor, minBufferSize = _a.minBufferSize, thresholds = _a.thresholds;\n    var points = scene.scene.children[POINT_MESH_INDEX];\n    // If the amount of data being sent to the chart scene surpasses the size of the buffers within the\n    // chart scene, we must fully recreate the chart scene. This is a costly operation.\n    var isDataOverflowingBuffer = maxDataPointsRendered(points) < numDataPoints(dataStreams);\n    if (isDataOverflowingBuffer || needsNewClipSpace(viewPort, scene.toClipSpace)) {\n        return chartScene({\n            dataStreams: dataStreams,\n            chartSize: chartSize,\n            dataStreamInfo: dataStreamInfo,\n            container: container,\n            viewPort: viewPort,\n            minBufferSize: minBufferSize,\n            bufferFactor: bufferFactor,\n            thresholds: thresholds,\n        });\n    }\n    if (hasDataChanged) {\n        updatePointMesh(dataStreams, dataStreamInfo, points, scene.toClipSpace);\n    }\n    // Return existing scene.\n    return scene;\n};\n// The initial size of buffers. The larger this is, the more memory allocated up front per chart.\n// The lower this number is, more likely that charts will have to re-initialize there buffers which is\n// a slow operation (CPU bound).\nvar DEFAULT_MIN_BUFFER_SIZE = 1000;\nvar DEFAULT_BUFFER_FACTOR = 2;\nvar MonitorScatterChart = /** @class */ (function () {\n    function MonitorScatterChart(hostRef) {\n        registerInstance(this, hostRef);\n        this.isLoading = false;\n        this.isEditing = false;\n        this.isFetching = false;\n        this.errorMap = {};\n        this.bufferFactor = DEFAULT_BUFFER_FACTOR;\n        this.minBufferSize = DEFAULT_MIN_BUFFER_SIZE;\n    }\n    MonitorScatterChart.prototype.render = function () {\n        var _this = this;\n        return (h(\"monitor-size-provider\", { size: this.config.size, renderFunc: function (rect) { return (h(\"monitor-viewport-provider\", { dataStreams: _this.data, config: _this.config, renderFunc: function (yRange) { return (h(\"monitor-webgl-base-chart\", { configId: _this.config.id, legend: _this.config.legend, annotations: _this.annotations, updateChartScene: updateChartScene, createChartScene: chartScene, dataStreamInfo: _this.config.dataStreamInfo, errorMap: _this.errorMap, size: Object.assign(Object.assign(Object.assign({}, DEFAULT_CHART_CONFIG.size), _this.config.size), rect), data: _this.data, viewPort: Object.assign(Object.assign({}, _this.config.viewPort), yRange), minBufferSize: _this.minBufferSize, bufferFactor: _this.bufferFactor, isEditing: _this.isEditing, isFetching: _this.isFetching, isLoading: _this.isLoading })); } })); } }));\n    };\n    return MonitorScatterChart;\n}());\nexport { MonitorScatterChart as monitor_scatter_chart };\n","// NOTE: `enum`s are held separately from the types which are exported\n// as part of the package, since `enum`'s cannot be present in a type declaration file.\n// THis is due to an `enum` being a type plus an implementation, while type declaration\n// files can only contain typing information.\n/**\n * Maps the view model to d3 axis types. In the future we could add additional\n * custom scale types beyond what's available in `d3-axis`.\n */\nvar ScaleType;\n(function (ScaleType) {\n    ScaleType[\"TimeSeries\"] = \"time-series\";\n    ScaleType[\"Log\"] = \"log\";\n    ScaleType[\"Linear\"] = \"linear\";\n})(ScaleType || (ScaleType = {}));\nvar LEGEND_POSITION;\n(function (LEGEND_POSITION) {\n    LEGEND_POSITION[\"RIGHT\"] = \"RIGHT\";\n    LEGEND_POSITION[\"BOTTOM\"] = \"BOTTOM\";\n})(LEGEND_POSITION || (LEGEND_POSITION = {}));\nexport { LEGEND_POSITION as L, ScaleType as S };\n","var SECOND_IN_MS = 1000;\nvar MINUTE_IN_MS = 60 * SECOND_IN_MS;\nvar HOUR_IN_MS = 60 * MINUTE_IN_MS;\nvar DAY_IN_MS = 24 * HOUR_IN_MS;\n// Not precisely accurate, only estimates. exact duration depends on start date. use with care.\nvar MONTH_IN_MS = 30 * DAY_IN_MS;\nvar YEAR_IN_MS = 12 * MONTH_IN_MS;\n/**\n * ConvertMS is a helper function that will take in milliseconds and convert it to the highest detonator\n * and does not return the \"remainder\"\n *\n * It is important to note that the object returning does not represent equivalence!\n *\n * For Example:\n * convert(MINUTE_IN_MS) will return:\n * {\n *   day: 0,\n *   hour: 0\n *   minute: 1,\n *   seconds: 0,\n * }\n *\n * IT DOES NOT RETURN:\n *\n * {\n *   day: 0,\n *   hour: 0,\n *   minute: 1,\n *   seconds: 60, <--- does not return the \"equivalence\"\n * }\n */\nvar convertMS = function (milliseconds) {\n    if (milliseconds < 0) {\n        throw new Error('Time cannot be negative!');\n    }\n    var seconds = Math.floor(milliseconds / 1000);\n    var minute = Math.floor(seconds / 60);\n    var hour = Math.floor(minute / 60);\n    var day = Math.floor(hour / 24);\n    seconds %= 60;\n    minute %= 60;\n    hour %= 24;\n    return {\n        day: day,\n        hour: hour,\n        minute: minute,\n        seconds: seconds,\n    };\n};\nvar displayDate = function (date, resolution, _a) {\n    var start = _a.start, end = _a.end;\n    if (resolution < DAY_IN_MS) {\n        var viewPortDurationMS = end.getTime() - start.getTime();\n        if (viewPortDurationMS < MINUTE_IN_MS) {\n            return date.toLocaleString('en-US', {\n                minute: 'numeric',\n                second: 'numeric',\n            });\n        }\n        if (viewPortDurationMS < 10 * MINUTE_IN_MS) {\n            return date.toLocaleString('en-US', {\n                hour: 'numeric',\n                minute: 'numeric',\n                second: 'numeric',\n                hour12: true,\n            });\n        }\n        return date.toLocaleString('en-US', {\n            hour: 'numeric',\n            minute: 'numeric',\n            hour12: true,\n        });\n    }\n    if (resolution <= HOUR_IN_MS) {\n        return date.toLocaleString('en-US', {\n            hour: 'numeric',\n            day: 'long',\n            hour12: true,\n        });\n    }\n    if (resolution <= DAY_IN_MS) {\n        return date.toLocaleString('en-US', {\n            day: 'numeric',\n            month: 'long',\n        });\n    }\n    return date.toLocaleString('en-US', {\n        year: 'numeric',\n        month: 'long',\n    });\n};\nexport { DAY_IN_MS as D, HOUR_IN_MS as H, MINUTE_IN_MS as M, SECOND_IN_MS as S, YEAR_IN_MS as Y, MONTH_IN_MS as a, convertMS as c, displayDate as d };\n","import { S as ScaleType, L as LEGEND_POSITION } from './constants-2dc21ff9.js';\nvar DEFAULT_CHART_CONFIG = {\n    id: 'fake-id',\n    viewPort: {\n        start: new Date(1995, 0, 0, 0),\n        end: new Date(2020, 1, 0, 0),\n        yMin: 0,\n        yMax: 10000,\n    },\n    // width is width - marginLeft - marginRight\n    size: { width: 400 + 50 + 25, height: 350, marginLeft: 50, marginRight: 50, marginTop: 8, marginBottom: 30 },\n    movement: {\n        enableXScroll: true,\n        enableYScroll: false,\n        zoomMax: Infinity,\n        zoomMin: 0.00001,\n    },\n    layout: {\n        xGridVisible: false,\n        yGridVisible: true,\n        xTicksVisible: true,\n        yTicksVisible: true,\n    },\n    scale: {\n        xScaleType: ScaleType.TimeSeries,\n        yScaleType: ScaleType.Linear,\n        xScaleSide: 'bottom',\n        yScaleSide: 'left',\n    },\n    dataStreamInfo: [],\n    legend: {\n        position: LEGEND_POSITION.BOTTOM,\n        width: 180,\n    },\n};\nexport { DEFAULT_CHART_CONFIG as D };\n","import { M as MINUTE_IN_MS, D as DAY_IN_MS, S as SECOND_IN_MS, Y as YEAR_IN_MS } from './time-cc688558.js';\n/**\n * Clip Space Conversion Utilities\n *\n * Our 'model' space utilizes milliseconds to represent time. This level of granularity is important\n * since we do wish to be able to visually represent the time differences at that level of detail.\n *\n * However, there are 3.15e+10 milliseconds in a year. This is problematic because it means that we cannot represent\n * a years worth of data at the millisecond level granularity utilizing 32 bit floats.\n *\n * double precision is not supported by webGL - there are ways to represent double precision, however these\n * are unnecessarily complicated, double our memory foot print, and actually not necessary.\n *\n * Interesting article on doubles: http://blog.hvidtfeldts.net/index.php/2012/07/double-precision-in-opengl-and-webgl/\n *\n * ## Why Not Necessary To Utilize Doubles?\n *\n * While we need millisecond level precision, we do not need to be able to visually differentiate between milliseconds\n * while looking at even a weeks worth of data. Even if we did, you would not be able to discern a difference\n * due to resolution limitations. Even if you had a hypothetically perfect monitor that could discern a planks-constant\n * level of resolution, the eye would not be able to tell without advanced optical instrumentation!\n *\n * ## Solution\n *\n * We do two things to mitigate - based on the time duration of a given viewport, we will scale down the numbers and\n * truncate the decimals such that the distance from the end to the start of the viewport is representable by a floating point.\n *\n * However, this leaves one more problem - imagine after scaling our viewport in our clip space, we could have\n * our start be 1.20001e+8 to 1.20002e+8, we would have a distance of 1000, which is representable by a 32 bit float, however\n * each number within that range is still not representable by a 32 bit float. To account for this, we also must translate our clip\n * space by what we refer to as an anchor. Suppose we utilize 1.2*10^8 as an anchor, our clip space time range is now 1000 to 2000.\n * Success! We can now represent our time within webgl by a 32 bit float.\n *\n * ## Caveats\n *\n * Since the viewport is dynamic, we have to make sure that as our viewport moves around, we update our `clip space conversion`.\n * Translating, scaling-in, and scaling-out can all cause our `clip space conversion` to start outputting numbers which are not representable by 32 bit floats.\n * To solve this, we also must make sure we watch for viewport changes and adjust our conversion accordingly.\n */\n/**\n * Granularity\n *\n * given a duration, return the granularity in milliseconds.\n * By granularity we mean the minimal time difference which is visually differentiated.\n */\nvar granularity = function (durationMS) {\n    if (durationMS < 10 * MINUTE_IN_MS) {\n        // single millisecond\n        return 1;\n    }\n    if (durationMS < DAY_IN_MS) {\n        return SECOND_IN_MS / 10;\n    }\n    if (durationMS < DAY_IN_MS * 7) {\n        return SECOND_IN_MS;\n    }\n    if (durationMS < YEAR_IN_MS) {\n        return MINUTE_IN_MS;\n    }\n    if (durationMS < 30 * YEAR_IN_MS) {\n        return 30 * MINUTE_IN_MS;\n    }\n    return DAY_IN_MS;\n};\n/**\n * Clip Space Conversion\n *\n * Converts something from model space (millisecond representation of time) into our clip space.\n * The goal is to be able to represent the time from `start` to `end` with floating point precision (7 significant digits).\n */\nvar clipSpaceConversion = function (viewPort) {\n    var durationMS = viewPort.end.getTime() - viewPort.start.getTime();\n    var anchorMS = viewPort.start.getTime() - durationMS * 0.25;\n    var granularityMS = granularity(durationMS);\n    return function (t) { return Math.floor((t - anchorMS) / granularityMS); };\n};\nvar FLOAT_SIG_FIGS = 7;\nvar isDateOutOfBounds = function (date, toClipSpace) { return Math.abs(toClipSpace(date.getTime())) >= Math.pow(10, FLOAT_SIG_FIGS); };\n// Minimum amount of distinct positions our clip spaces needs to represent.\nvar MIN_GRANULARITY = 3000;\n/**\n * Needs New Clip Space\n *\n * There are two conditions which can occur which will require a new clip space.\n *\n * 1. The viewport when mapped to the clip space, contains numbers that aren't representable by floating point precision.\n * 2. The granularity within the viewport mapped to the clip space is too low - i.e. if the viewport maps to [0, 10],\n *    then we can only represent 11 distinct points.\n */\nvar needsNewClipSpace = function (viewPort, toClipSpace) {\n    var isOutOfBounds = isDateOutOfBounds(viewPort.start, toClipSpace) || isDateOutOfBounds(viewPort.end, toClipSpace);\n    var distanceMS = viewPort.end.getTime() - viewPort.start.getTime();\n    var distanceClipSpace = toClipSpace(viewPort.end.getTime()) - toClipSpace(viewPort.start.getTime());\n    var hasTooLowGranularity = distanceMS > distanceClipSpace && distanceClipSpace < MIN_GRANULARITY;\n    return isOutOfBounds || hasTooLowGranularity;\n};\nexport { clipSpaceConversion as c, needsNewClipSpace as n };\n","import { n as numDataPoints, B as BufferGeometry, S as ShaderMaterial, P as Points, v as vertices, a as BufferAttribute } from './utils-ef59b734.js';\nvar shaderVert = \"\\nvarying vec3 vColor;\\nattribute vec3 pointColor;\\nuniform float pointDiameter;\\nuniform float devicePixelRatio;\\n\\nvoid main() {\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x, position.y, 0.0, 1.0);\\n  gl_PointSize = pointDiameter * devicePixelRatio;\\n  vColor = pointColor;\\n}\\n\";\nvar shaderFrag = \"\\nvarying vec3 vColor;\\n\\nvoid main() {\\n  // calculate position such that the center is (0, 0) in a region of [-1, 1] x [-1, 1]\\n  vec2 pos = 2.0 * gl_PointCoord.xy - 1.0;\\n  // r = distance squared from the origin of the point being rendered\\n  float r = dot(pos, pos);\\n  if (r > 1.0) {\\n    discard;\\n  }\\n  float alpha = 1.0 - smoothstep(0.5, 1.0, sqrt(r));\\n  gl_FragColor = vec4(vColor, alpha);\\n}\\n\";\nvar POINT_MESH_INDEX = 0;\nvar POINT_DIAMETER = 6.25;\nvar RAW_POINT_DIAMETER = 4;\n/**\n * Get the diameter of the points to display on the chart.\n *\n * We want to display points smaller for raw data since they may be displayed very densely\n */\nvar pointDiameter = function (dataStreams) {\n    var resolution = dataStreams[0] != null ? dataStreams[0].resolution : null;\n    return resolution === 0 ? RAW_POINT_DIAMETER : POINT_DIAMETER;\n};\n/**\n * Create Point Mesh\n *\n * The representation of the points on a chart.\n */\n// Used to set the default buffer size for a given chart - the larger this is set to, the more memory will be allocated\n// up front per `ChartScene`.\nvar NUM_POSITION_COMPONENTS = 2; // (x, y)\nvar NUM_COLOR_COMPONENTS = 3; // (r, g, b)\n/**\n * Update Geometry\n *\n * Updates the color, and position of the vertices sent down to the vertex shader.\n */\nvar updateGeometry = function (geometry, dataStreams, dataStreamInfo, toClipSpace) {\n    var streamVertexSets = dataStreams.map(function (stream) {\n        var info = dataStreamInfo.find(function (_a) {\n            var id = _a.id;\n            return stream.id === id;\n        });\n        if (info == null) {\n            throw new Error(\"data streams must have an associated data stream info.\\n         missing the data stream info for data stream id: \" + stream.id);\n        }\n        return vertices(stream, info);\n    });\n    var allVertices = streamVertexSets.flat();\n    var _a = geometry.attributes, position = _a.position, pointColor = _a.pointColor;\n    /**\n     * Fill Buffers with data\n     */\n    allVertices.forEach(function (_a, i) {\n        var x = _a[0], y = _a[1], r = _a[2], g = _a[3], b = _a[4];\n        // Set Position\n        position.array[i * NUM_POSITION_COMPONENTS] = toClipSpace(x);\n        position.array[i * NUM_POSITION_COMPONENTS + 1] = y;\n        // Set Normal Data Stream Color\n        pointColor.array[i * NUM_COLOR_COMPONENTS] = r;\n        pointColor.array[i * NUM_COLOR_COMPONENTS + 1] = g;\n        pointColor.array[i * NUM_COLOR_COMPONENTS + 2] = b;\n    });\n    geometry.setDrawRange(0, allVertices.length);\n    position.needsUpdate = true;\n    pointColor.needsUpdate = true;\n};\nvar initializeGeometry = function (geometry, bufferSize) {\n    // TODO(btd): Change to double precision\n    geometry.setAttribute('position', new BufferAttribute(new Float32Array(bufferSize * NUM_POSITION_COMPONENTS), NUM_POSITION_COMPONENTS));\n    geometry.setAttribute('pointColor', new BufferAttribute(new Uint8Array(bufferSize * NUM_COLOR_COMPONENTS), NUM_COLOR_COMPONENTS, true));\n};\n/**\n * Create Point Mesh\n */\nvar pointMesh = function (_a) {\n    var toClipSpace = _a.toClipSpace, dataStreams = _a.dataStreams, dataStreamInfo = _a.dataStreamInfo, minBufferSize = _a.minBufferSize, bufferFactor = _a.bufferFactor;\n    var bufferSize = Math.max(minBufferSize, numDataPoints(dataStreams) * bufferFactor);\n    var geometry = new BufferGeometry();\n    initializeGeometry(geometry, bufferSize);\n    updateGeometry(geometry, dataStreams, dataStreamInfo, toClipSpace);\n    var material = new ShaderMaterial({\n        vertexShader: shaderVert,\n        fragmentShader: shaderFrag,\n        transparent: true,\n        uniforms: {\n            pointDiameter: {\n                value: pointDiameter(dataStreams),\n            },\n            devicePixelRatio: {\n                value: window.devicePixelRatio,\n            },\n        },\n    });\n    var points = new Points(geometry, material);\n    // Prevent computeBoundingSphere from being called\n    points.frustumCulled = false;\n    return points;\n};\n/**\n * Update Point Mesh\n *\n * Updates the point mesh to match the given data stream info and data streams.\n * Increases size of attribute buffers if necessary.\n */\nvar updatePointMesh = function (dataStreams, dataStreamInfo, points, toClipSpace) {\n    // eslint-disable-next-line no-param-reassign\n    points.material.uniforms.pointDiameter.value = pointDiameter(dataStreams);\n    updateGeometry(points.geometry, dataStreams, dataStreamInfo, toClipSpace);\n};\nexport { NUM_POSITION_COMPONENTS as N, POINT_MESH_INDEX as P, pointMesh as p, updatePointMesh as u };\n"],"sourceRoot":""}