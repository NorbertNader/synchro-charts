{"version":3,"sources":["../node_modules/@amzn/bp-components/dist/esm-es5/chartScene-551b2a63.js","../node_modules/@amzn/bp-components/dist/esm-es5/monitor-bar-chart.entry.js","../node_modules/@amzn/bp-components/dist/esm-es5/constants-2dc21ff9.js","../node_modules/@amzn/bp-components/dist/esm-es5/time-cc688558.js","../node_modules/@amzn/bp-components/dist/esm-es5/chartDefaults-5713566e.js","../node_modules/@amzn/bp-components/dist/esm-es5/clipSpaceConversion-2f416caa.js"],"names":["getDistanceFromDuration","toClipSpace","milliseconds","Math","abs","Date","getTime","getBarWidth","_a","resolution","numDataStreams","getBarMargin","getUniformWidth","dataStreams","length","updateMesh","dataStreamInfo","mesh","streamVertexSets","map","stream","info","find","id","Error","vertices","count","reduce","totalBars","streamVertexSet","max","numBars","_b","geometry","attributes","color","bar","positionIndex","colorIndex","forEach","setIndex","currVertex","currX","currY","r","g","b","array","needsUpdate","unitSquare","barMesh","bufferFactor","minBufferSize","instGeo","InstancedBufferGeometry","bufferSize","numDataPoints","setAttribute","BufferAttribute","Float32Array","InstancedBufferAttribute","Uint8Array","initializeGeometry","barChartMaterial","RawShaderMaterial","vertexShader","fragmentShader","side","DoubleSide","transparent","uniforms","width","value","InstancedMesh","frustumCulled","chartScene","container","viewPort","scene","Scene","clipSpaceConversion","add","constructChartScene","updateChartScene","hasDataChanged","chartSize","bars","children","maxDataPointsRendered","needsNewClipSpace","thresholds","material","updateBarMesh","MonitorBarChart","hostRef","registerInstance","this","isEditing","isLoading","isFetching","errorMap","prototype","render","_this","h","size","config","renderFunc","data","preferStartFromZero","yRange","configId","legend","annotations","createChartScene","Object","assign","DEFAULT_CHART_CONFIG","ScaleType","LEGEND_POSITION","SECOND_IN_MS","MINUTE_IN_MS","HOUR_IN_MS","DAY_IN_MS","MONTH_IN_MS","YEAR_IN_MS","convertMS","seconds","floor","minute","hour","day","displayDate","date","start","end","viewPortDurationMS","toLocaleString","second","hour12","month","year","yMin","yMax","height","marginLeft","marginRight","marginTop","marginBottom","movement","enableXScroll","enableYScroll","zoomMax","Infinity","zoomMin","layout","xGridVisible","yGridVisible","xTicksVisible","yTicksVisible","scale","xScaleType","TimeSeries","yScaleType","Linear","xScaleSide","yScaleSide","position","BOTTOM","durationMS","anchorMS","granularityMS","granularity","t","isDateOutOfBounds","pow","isOutOfBounds","distanceMS","distanceClipSpace"],"mappings":"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","file":"static/js/stencil-monitor-bar-chart-entry-js.059323d2.chunk.js","sourcesContent":["import { I as InstancedBufferGeometry, n as numDataPoints, R as RawShaderMaterial, D as DoubleSide, b as InstancedMesh, v as vertices, a as BufferAttribute, c as InstancedBufferAttribute, d as constructChartScene, e as Scene } from './utils-ef59b734.js';\nimport { c as clipSpaceConversion, n as needsNewClipSpace } from './clipSpaceConversion-2f416caa.js';\n/* eslint-disable max-len */\nvar barVert = \"\\nprecision highp float;\\nuniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform float width;\\nattribute vec2 bar;\\nattribute vec2 position;\\nattribute vec3 color;\\nvarying vec3 vColor;\\n\\nvoid main() {\\n  // Negative width here because we want to render the bars' width to the left side starting from its x position.\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x * -width + bar.x, position.y * bar.y, 0.0, 1.0);\\n  vColor = color;\\n}\\n\";\nvar barFrag = \"\\nprecision highp float;\\nvarying vec3 vColor;\\n\\nvoid main() {\\n  gl_FragColor = vec4(vColor, 1.0);\\n}\\n\";\n/**\n * Display Constants\n *\n * Adjust these to scale the margins provided within the bar chart.\n * This represent which fraction of the 'width' of a given bar group a margin.\n */\nvar MARGIN_FACTOR = 1 / 6;\n/**\n *\n * Get Distance from Duration\n *\n * Return distance between `milliseconds` on a given `xScale`, assuming `xScale` is linear.\n * If `xScale` is not linear, the distance between two points can depend on the exact value of time,\n * rather than just the time between. Non-linear `xScale` requires the width to be computed for every point rather\n * than just once.\n *\n * Since a non-linear xAxis is an un-common use case we won't support that for now.\n */\nvar getDistanceFromDuration = function (toClipSpace, milliseconds) { return Math.abs(toClipSpace(new Date(milliseconds).getTime()) - toClipSpace(new Date(0).getTime())); };\nvar getBarMargin = function (toClipSpace, resolution) { return getDistanceFromDuration(toClipSpace, resolution * MARGIN_FACTOR); };\n/**\n * Get the bar width\n *\n * Returns the clipSpace width which each bar should be.\n * It is assumed that each bar within a group will have the same width.\n */\nvar getBarWidth = function (_a) {\n    var toClipSpace = _a.toClipSpace, resolution = _a.resolution, numDataStreams = _a.numDataStreams;\n    return (getDistanceFromDuration(toClipSpace, resolution) - getBarMargin(toClipSpace, resolution)) / numDataStreams;\n};\n// Used to set the default buffer size for a given chart - the larger this is set to, the more memory will be allocated\n// up front per `ChartScene`.\nvar NUM_POSITION_COMPONENTS = 2; // (x, y)\nvar NUM_COLOR_COMPONENTS = 3; // (r, g, b)\nvar numBars = function (streamVertexSets) {\n    var bars = streamVertexSets.reduce(function (totalBars, streamVertexSet) {\n        var streamBars = Math.max(streamVertexSet.length, 0);\n        return totalBars + streamBars;\n    }, 0);\n    return bars;\n};\nvar getUniformWidth = function (dataStreams, toClipSpace) {\n    if (dataStreams.length === 0) {\n        return 0;\n    }\n    var resolution = dataStreams[0].resolution;\n    return getBarWidth({\n        toClipSpace: toClipSpace,\n        numDataStreams: dataStreams.length,\n        resolution: resolution,\n    });\n};\nvar updateMesh = function (_a) {\n    var dataStreams = _a.dataStreams, dataStreamInfo = _a.dataStreamInfo, mesh = _a.mesh, toClipSpace = _a.toClipSpace;\n    var streamVertexSets = dataStreams.map(function (stream) {\n        var info = dataStreamInfo.find(function (_a) {\n            var id = _a.id;\n            return stream.id === id;\n        });\n        if (info == null) {\n            throw new Error(\"data streams must have an associated data stream info.\\n         missing the data stream info for data stream id: \" + stream.id);\n        }\n        return vertices(stream, info);\n    });\n    // Set the number of instances of the bar are to be rendered.\n    // eslint-disable-next-line no-param-reassign\n    mesh.count = numBars(streamVertexSets);\n    var geometry = mesh.geometry;\n    var _b = geometry.attributes, color = _b.color, bar = _b.bar;\n    var positionIndex = 0;\n    var colorIndex = 0;\n    streamVertexSets.forEach(function (streamVertexSet, setIndex) {\n        streamVertexSet.forEach(function (currVertex) {\n            var currX = currVertex[0], currY = currVertex[1], r = currVertex[2], g = currVertex[3], b = currVertex[4];\n            /**\n             * Subtracting setIndex * getUniformWidth(dataStreams, toClipSpace) because with each new\n             * data stream, we want to render it side by side on the left side.\n             */\n            bar.array[positionIndex] = toClipSpace(currX) - setIndex * getUniformWidth(dataStreams, toClipSpace);\n            bar.array[positionIndex + 1] = currY;\n            // Set bar color (r, g, b)\n            color.array[colorIndex] = r;\n            color.array[colorIndex + 1] = g;\n            color.array[colorIndex + 2] = b;\n            // Increment Indexes by the associated stride of the buffer\n            colorIndex += NUM_COLOR_COMPONENTS;\n            positionIndex += NUM_POSITION_COMPONENTS;\n        });\n    });\n    bar.needsUpdate = true;\n    color.needsUpdate = true;\n};\n// https://wwwtyro.net/2019/11/18/instanced-lines.html\n// 2d vertices composing of two triangles which make up a square\n// (0, 1) - - - (1, 1)\n//   |  \\         |\n//   |     \\      |\n//   |        \\   |\n// (0, 0) - - - (1, 0)\nvar unitSquare = [0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1];\nvar initializeGeometry = function (geometry, bufferSize) {\n    geometry.setAttribute('position', new BufferAttribute(new Float32Array(unitSquare), NUM_POSITION_COMPONENTS));\n    geometry.setAttribute('bar', new InstancedBufferAttribute(new Float32Array(bufferSize * NUM_POSITION_COMPONENTS), NUM_POSITION_COMPONENTS, false));\n    geometry.setAttribute('color', new InstancedBufferAttribute(new Uint8Array(bufferSize * NUM_COLOR_COMPONENTS), NUM_COLOR_COMPONENTS, true));\n};\nvar barMesh = function (_a) {\n    var dataStreams = _a.dataStreams, dataStreamInfo = _a.dataStreamInfo, toClipSpace = _a.toClipSpace, bufferFactor = _a.bufferFactor, minBufferSize = _a.minBufferSize;\n    var instGeo = new InstancedBufferGeometry();\n    var bufferSize = Math.max(minBufferSize, numDataPoints(dataStreams) * bufferFactor);\n    // Create and populate geometry\n    initializeGeometry(instGeo, bufferSize);\n    /**\n     * Create Bar Mesh\n     *\n     * The representation of the bars on a bar chart.\n     *\n     * Utilizes an instance of a single unit square, which then gets\n     * stretched and transposed across the canvas.\n     */\n    var barChartMaterial = new RawShaderMaterial({\n        vertexShader: barVert,\n        fragmentShader: barFrag,\n        side: DoubleSide,\n        transparent: false,\n        uniforms: {\n            width: {\n                value: getUniformWidth(dataStreams, toClipSpace),\n            },\n        },\n    });\n    var mesh = new InstancedMesh(instGeo, barChartMaterial, bufferSize);\n    updateMesh({ dataStreams: dataStreams, dataStreamInfo: dataStreamInfo, mesh: mesh, toClipSpace: toClipSpace });\n    // Prevent bounding sphere from being called\n    mesh.frustumCulled = false;\n    return mesh;\n};\nvar updateBarMesh = function (_a) {\n    var bars = _a.bars, dataStreams = _a.dataStreams, dataStreamInfo = _a.dataStreamInfo, toClipSpace = _a.toClipSpace, hasDataChanged = _a.hasDataChanged;\n    if (hasDataChanged) {\n        // eslint-disable-next-line no-param-reassign\n        bars.material.uniforms.width.value = getUniformWidth(dataStreams, toClipSpace);\n        updateMesh({ dataStreams: dataStreams, dataStreamInfo: dataStreamInfo, mesh: bars, toClipSpace: toClipSpace });\n    }\n};\nvar maxDataPointsRendered = function (bars) { return bars.geometry.attributes.bar.array.length / NUM_POSITION_COMPONENTS; };\nvar chartScene = function (_a) {\n    var dataStreams = _a.dataStreams, dataStreamInfo = _a.dataStreamInfo, container = _a.container, viewPort = _a.viewPort, bufferFactor = _a.bufferFactor, minBufferSize = _a.minBufferSize;\n    var scene = new Scene();\n    var toClipSpace = clipSpaceConversion(viewPort);\n    scene.add(barMesh({ dataStreams: dataStreams, dataStreamInfo: dataStreamInfo, toClipSpace: toClipSpace, bufferFactor: bufferFactor, minBufferSize: minBufferSize }));\n    return constructChartScene({ scene: scene, viewPort: viewPort, container: container, toClipSpace: toClipSpace });\n};\nvar updateChartScene = function (_a) {\n    var scene = _a.scene, dataStreams = _a.dataStreams, dataStreamInfo = _a.dataStreamInfo, hasDataChanged = _a.hasDataChanged, minBufferSize = _a.minBufferSize, bufferFactor = _a.bufferFactor, viewPort = _a.viewPort, container = _a.container, chartSize = _a.chartSize;\n    var bars = scene.scene.children[0];\n    // If the amount of data being sent to the chart scene surpasses the size of the buffers within the\n    // chart scene, we must fully recreate the chart scene. This is a costly operation.\n    var isDataOverflowingBuffer = maxDataPointsRendered(bars) < numDataPoints(dataStreams);\n    if (isDataOverflowingBuffer || needsNewClipSpace(viewPort, scene.toClipSpace)) {\n        // TODO: fix me\n        return chartScene({\n            dataStreams: dataStreams,\n            dataStreamInfo: dataStreamInfo,\n            container: container,\n            viewPort: viewPort,\n            minBufferSize: minBufferSize,\n            bufferFactor: bufferFactor,\n            chartSize: chartSize,\n            thresholds: [],\n        });\n    }\n    updateBarMesh({\n        bars: bars,\n        dataStreams: dataStreams,\n        dataStreamInfo: dataStreamInfo,\n        toClipSpace: scene.toClipSpace,\n        hasDataChanged: hasDataChanged,\n    });\n    return scene;\n};\nexport { chartScene as c, updateChartScene as u };\n","import { r as registerInstance, h } from './index-326b73e4.js';\nimport './types-ef93b8eb.js';\nimport './constants-2dc21ff9.js';\nimport './time-cc688558.js';\nimport './_commonjsHelpers-17042db9.js';\nimport { D as DEFAULT_CHART_CONFIG } from './chartDefaults-5713566e.js';\nimport './utils-ef59b734.js';\nimport './v4-1d709f5b.js';\nimport './index-085eab52.js';\nimport './predicates-4851c065.js';\nimport './clipSpaceConversion-2f416caa.js';\nimport { u as updateChartScene, c as chartScene } from './chartScene-551b2a63.js';\n// The initial size of buffers. The larger this is, the more memory allocated up front per chart.\n// The lower this number is, more likely that charts will have to re-initialize there buffers which is\n// a slow operation (CPU bound).\nvar DEFAULT_MIN_BUFFER_SIZE = 1000;\nvar DEFAULT_BUFFER_FACTOR = 2;\nvar MonitorBarChart = /** @class */ (function () {\n    function MonitorBarChart(hostRef) {\n        registerInstance(this, hostRef);\n        this.isEditing = false;\n        this.isLoading = false;\n        this.isFetching = false;\n        this.errorMap = {};\n        this.bufferFactor = DEFAULT_BUFFER_FACTOR;\n        this.minBufferSize = DEFAULT_MIN_BUFFER_SIZE;\n    }\n    MonitorBarChart.prototype.render = function () {\n        var _this = this;\n        return (h(\"monitor-size-provider\", { size: this.config.size, renderFunc: function (size) { return (h(\"monitor-viewport-provider\", { dataStreams: _this.data, config: _this.config, preferStartFromZero: true, renderFunc: function (yRange) { return (h(\"monitor-webgl-base-chart\", { configId: _this.config.id, legend: _this.config.legend, annotations: _this.annotations, updateChartScene: updateChartScene, createChartScene: chartScene, dataStreamInfo: _this.config.dataStreamInfo, errorMap: _this.errorMap, size: Object.assign(Object.assign(Object.assign({}, DEFAULT_CHART_CONFIG.size), _this.config.size), size), data: _this.data, viewPort: Object.assign(Object.assign({}, _this.config.viewPort), yRange), minBufferSize: _this.minBufferSize, bufferFactor: _this.bufferFactor, isEditing: _this.isEditing, isFetching: _this.isFetching, isLoading: _this.isLoading })); } })); } }));\n    };\n    return MonitorBarChart;\n}());\nexport { MonitorBarChart as monitor_bar_chart };\n","// NOTE: `enum`s are held separately from the types which are exported\n// as part of the package, since `enum`'s cannot be present in a type declaration file.\n// THis is due to an `enum` being a type plus an implementation, while type declaration\n// files can only contain typing information.\n/**\n * Maps the view model to d3 axis types. In the future we could add additional\n * custom scale types beyond what's available in `d3-axis`.\n */\nvar ScaleType;\n(function (ScaleType) {\n    ScaleType[\"TimeSeries\"] = \"time-series\";\n    ScaleType[\"Log\"] = \"log\";\n    ScaleType[\"Linear\"] = \"linear\";\n})(ScaleType || (ScaleType = {}));\nvar LEGEND_POSITION;\n(function (LEGEND_POSITION) {\n    LEGEND_POSITION[\"RIGHT\"] = \"RIGHT\";\n    LEGEND_POSITION[\"BOTTOM\"] = \"BOTTOM\";\n})(LEGEND_POSITION || (LEGEND_POSITION = {}));\nexport { LEGEND_POSITION as L, ScaleType as S };\n","var SECOND_IN_MS = 1000;\nvar MINUTE_IN_MS = 60 * SECOND_IN_MS;\nvar HOUR_IN_MS = 60 * MINUTE_IN_MS;\nvar DAY_IN_MS = 24 * HOUR_IN_MS;\n// Not precisely accurate, only estimates. exact duration depends on start date. use with care.\nvar MONTH_IN_MS = 30 * DAY_IN_MS;\nvar YEAR_IN_MS = 12 * MONTH_IN_MS;\n/**\n * ConvertMS is a helper function that will take in milliseconds and convert it to the highest detonator\n * and does not return the \"remainder\"\n *\n * It is important to note that the object returning does not represent equivalence!\n *\n * For Example:\n * convert(MINUTE_IN_MS) will return:\n * {\n *   day: 0,\n *   hour: 0\n *   minute: 1,\n *   seconds: 0,\n * }\n *\n * IT DOES NOT RETURN:\n *\n * {\n *   day: 0,\n *   hour: 0,\n *   minute: 1,\n *   seconds: 60, <--- does not return the \"equivalence\"\n * }\n */\nvar convertMS = function (milliseconds) {\n    if (milliseconds < 0) {\n        throw new Error('Time cannot be negative!');\n    }\n    var seconds = Math.floor(milliseconds / 1000);\n    var minute = Math.floor(seconds / 60);\n    var hour = Math.floor(minute / 60);\n    var day = Math.floor(hour / 24);\n    seconds %= 60;\n    minute %= 60;\n    hour %= 24;\n    return {\n        day: day,\n        hour: hour,\n        minute: minute,\n        seconds: seconds,\n    };\n};\nvar displayDate = function (date, resolution, _a) {\n    var start = _a.start, end = _a.end;\n    if (resolution < DAY_IN_MS) {\n        var viewPortDurationMS = end.getTime() - start.getTime();\n        if (viewPortDurationMS < MINUTE_IN_MS) {\n            return date.toLocaleString('en-US', {\n                minute: 'numeric',\n                second: 'numeric',\n            });\n        }\n        if (viewPortDurationMS < 10 * MINUTE_IN_MS) {\n            return date.toLocaleString('en-US', {\n                hour: 'numeric',\n                minute: 'numeric',\n                second: 'numeric',\n                hour12: true,\n            });\n        }\n        return date.toLocaleString('en-US', {\n            hour: 'numeric',\n            minute: 'numeric',\n            hour12: true,\n        });\n    }\n    if (resolution <= HOUR_IN_MS) {\n        return date.toLocaleString('en-US', {\n            hour: 'numeric',\n            day: 'long',\n            hour12: true,\n        });\n    }\n    if (resolution <= DAY_IN_MS) {\n        return date.toLocaleString('en-US', {\n            day: 'numeric',\n            month: 'long',\n        });\n    }\n    return date.toLocaleString('en-US', {\n        year: 'numeric',\n        month: 'long',\n    });\n};\nexport { DAY_IN_MS as D, HOUR_IN_MS as H, MINUTE_IN_MS as M, SECOND_IN_MS as S, YEAR_IN_MS as Y, MONTH_IN_MS as a, convertMS as c, displayDate as d };\n","import { S as ScaleType, L as LEGEND_POSITION } from './constants-2dc21ff9.js';\nvar DEFAULT_CHART_CONFIG = {\n    id: 'fake-id',\n    viewPort: {\n        start: new Date(1995, 0, 0, 0),\n        end: new Date(2020, 1, 0, 0),\n        yMin: 0,\n        yMax: 10000,\n    },\n    // width is width - marginLeft - marginRight\n    size: { width: 400 + 50 + 25, height: 350, marginLeft: 50, marginRight: 50, marginTop: 8, marginBottom: 30 },\n    movement: {\n        enableXScroll: true,\n        enableYScroll: false,\n        zoomMax: Infinity,\n        zoomMin: 0.00001,\n    },\n    layout: {\n        xGridVisible: false,\n        yGridVisible: true,\n        xTicksVisible: true,\n        yTicksVisible: true,\n    },\n    scale: {\n        xScaleType: ScaleType.TimeSeries,\n        yScaleType: ScaleType.Linear,\n        xScaleSide: 'bottom',\n        yScaleSide: 'left',\n    },\n    dataStreamInfo: [],\n    legend: {\n        position: LEGEND_POSITION.BOTTOM,\n        width: 180,\n    },\n};\nexport { DEFAULT_CHART_CONFIG as D };\n","import { M as MINUTE_IN_MS, D as DAY_IN_MS, S as SECOND_IN_MS, Y as YEAR_IN_MS } from './time-cc688558.js';\n/**\n * Clip Space Conversion Utilities\n *\n * Our 'model' space utilizes milliseconds to represent time. This level of granularity is important\n * since we do wish to be able to visually represent the time differences at that level of detail.\n *\n * However, there are 3.15e+10 milliseconds in a year. This is problematic because it means that we cannot represent\n * a years worth of data at the millisecond level granularity utilizing 32 bit floats.\n *\n * double precision is not supported by webGL - there are ways to represent double precision, however these\n * are unnecessarily complicated, double our memory foot print, and actually not necessary.\n *\n * Interesting article on doubles: http://blog.hvidtfeldts.net/index.php/2012/07/double-precision-in-opengl-and-webgl/\n *\n * ## Why Not Necessary To Utilize Doubles?\n *\n * While we need millisecond level precision, we do not need to be able to visually differentiate between milliseconds\n * while looking at even a weeks worth of data. Even if we did, you would not be able to discern a difference\n * due to resolution limitations. Even if you had a hypothetically perfect monitor that could discern a planks-constant\n * level of resolution, the eye would not be able to tell without advanced optical instrumentation!\n *\n * ## Solution\n *\n * We do two things to mitigate - based on the time duration of a given viewport, we will scale down the numbers and\n * truncate the decimals such that the distance from the end to the start of the viewport is representable by a floating point.\n *\n * However, this leaves one more problem - imagine after scaling our viewport in our clip space, we could have\n * our start be 1.20001e+8 to 1.20002e+8, we would have a distance of 1000, which is representable by a 32 bit float, however\n * each number within that range is still not representable by a 32 bit float. To account for this, we also must translate our clip\n * space by what we refer to as an anchor. Suppose we utilize 1.2*10^8 as an anchor, our clip space time range is now 1000 to 2000.\n * Success! We can now represent our time within webgl by a 32 bit float.\n *\n * ## Caveats\n *\n * Since the viewport is dynamic, we have to make sure that as our viewport moves around, we update our `clip space conversion`.\n * Translating, scaling-in, and scaling-out can all cause our `clip space conversion` to start outputting numbers which are not representable by 32 bit floats.\n * To solve this, we also must make sure we watch for viewport changes and adjust our conversion accordingly.\n */\n/**\n * Granularity\n *\n * given a duration, return the granularity in milliseconds.\n * By granularity we mean the minimal time difference which is visually differentiated.\n */\nvar granularity = function (durationMS) {\n    if (durationMS < 10 * MINUTE_IN_MS) {\n        // single millisecond\n        return 1;\n    }\n    if (durationMS < DAY_IN_MS) {\n        return SECOND_IN_MS / 10;\n    }\n    if (durationMS < DAY_IN_MS * 7) {\n        return SECOND_IN_MS;\n    }\n    if (durationMS < YEAR_IN_MS) {\n        return MINUTE_IN_MS;\n    }\n    if (durationMS < 30 * YEAR_IN_MS) {\n        return 30 * MINUTE_IN_MS;\n    }\n    return DAY_IN_MS;\n};\n/**\n * Clip Space Conversion\n *\n * Converts something from model space (millisecond representation of time) into our clip space.\n * The goal is to be able to represent the time from `start` to `end` with floating point precision (7 significant digits).\n */\nvar clipSpaceConversion = function (viewPort) {\n    var durationMS = viewPort.end.getTime() - viewPort.start.getTime();\n    var anchorMS = viewPort.start.getTime() - durationMS * 0.25;\n    var granularityMS = granularity(durationMS);\n    return function (t) { return Math.floor((t - anchorMS) / granularityMS); };\n};\nvar FLOAT_SIG_FIGS = 7;\nvar isDateOutOfBounds = function (date, toClipSpace) { return Math.abs(toClipSpace(date.getTime())) >= Math.pow(10, FLOAT_SIG_FIGS); };\n// Minimum amount of distinct positions our clip spaces needs to represent.\nvar MIN_GRANULARITY = 3000;\n/**\n * Needs New Clip Space\n *\n * There are two conditions which can occur which will require a new clip space.\n *\n * 1. The viewport when mapped to the clip space, contains numbers that aren't representable by floating point precision.\n * 2. The granularity within the viewport mapped to the clip space is too low - i.e. if the viewport maps to [0, 10],\n *    then we can only represent 11 distinct points.\n */\nvar needsNewClipSpace = function (viewPort, toClipSpace) {\n    var isOutOfBounds = isDateOutOfBounds(viewPort.start, toClipSpace) || isDateOutOfBounds(viewPort.end, toClipSpace);\n    var distanceMS = viewPort.end.getTime() - viewPort.start.getTime();\n    var distanceClipSpace = toClipSpace(viewPort.end.getTime()) - toClipSpace(viewPort.start.getTime());\n    var hasTooLowGranularity = distanceMS > distanceClipSpace && distanceClipSpace < MIN_GRANULARITY;\n    return isOutOfBounds || hasTooLowGranularity;\n};\nexport { clipSpaceConversion as c, needsNewClipSpace as n };\n"],"sourceRoot":""}