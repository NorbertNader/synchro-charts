{"version":3,"sources":["../node_modules/@amzn/bp-components/dist/esm-es5/chartSize-d34de530.js","../node_modules/@amzn/bp-components/dist/esm-es5/chartScene-492c5d48.js","../node_modules/@amzn/bp-components/dist/esm-es5/monitor-straight-line-segment-colored.entry.js","../node_modules/@amzn/bp-components/dist/esm-es5/time-cc688558.js","../node_modules/@amzn/bp-components/dist/esm-es5/clipSpaceConversion-2f416caa.js","../node_modules/@amzn/bp-components/dist/esm-es5/pointMesh-44019046.js","../node_modules/@amzn/bp-components/dist/esm-es5/webglContext-8b607584.js"],"names":["CHART_SIZE","width","height","pixelDensity","_a","_b","viewPort","end","start","yMax","yMin","toClipSpace","size","x","Math","abs","getTime","y","updateMesh","dataStreams","dataStreamInfo","mesh","streamVertexSets","map","stream","info","find","id","Error","vertices","count","reduce","totalSegments","streamVertexSet","max","length","numLineSegments","geometry","attributes","currPoint","nextPoint","segmentColor","positionIndex","colorIndex","forEach","currVertex","vertexNum","nextVertex","currX","currY","r","g","b","nextX","nextY","array","needsUpdate","segmentInstanceGeometry","lineMesh","chartSize","minBufferSize","bufferFactor","InstancedBufferGeometry","bufferSize","numDataPoints","setAttribute","BufferAttribute","Float32Array","flat","InstancedBufferAttribute","Uint8Array","initializeGeometry","xPixelDensity","yPixelDensity","lineMaterial","RawShaderMaterial","vertexShader","fragmentShader","side","DoubleSide","transparent","uniforms","value","InstancedMesh","frustumCulled","chartScene","container","onUpdate","scene","Scene","clipSpaceConversion","meshList","POINT_MESH_INDEX","pointMesh","add","constructChartScene","updateChartScene","hasDataChanged","lines","children","points","position","NUM_POSITION_COMPONENTS$1","maxDataPointsRendered","needsNewClipSpace","thresholds","material","updateLineMesh","updatePointMesh","X_MIN","Date","X_MAX","WIDTH","TEST_DATA_POINT_1","TEST_DATA_POINT_2","MonitorStraightLineSegment","hostRef","registerInstance","this","prototype","componentDidLoad","el","querySelector","data","resolution","name","color","webGLRenderer","addChartScene","setChartRect","getBoundingClientRect","render","h","style","Object","defineProperty","get","getElement","enumerable","configurable","SECOND_IN_MS","MINUTE_IN_MS","HOUR_IN_MS","DAY_IN_MS","MONTH_IN_MS","YEAR_IN_MS","convertMS","milliseconds","seconds","floor","minute","hour","day","displayDate","date","viewPortDurationMS","toLocaleString","second","hour12","month","year","durationMS","anchorMS","granularityMS","granularity","t","isDateOutOfBounds","pow","isOutOfBounds","distanceMS","distanceClipSpace","pointDiameter","NUM_POSITION_COMPONENTS","updateGeometry","allVertices","pointColor","i","setDrawRange","BufferGeometry","ShaderMaterial","devicePixelRatio","window","Points","rectScrollFixed","domRect","left","scrollX","right","bottom","scrollY","top","ClipSpaceRectMap","canvas","rectMap","updateCanvas","canvasRect","chartSceneId","rect","clipRect","containerRect","density","positiveYUpBottom","clipSpaceRect","undefined","removeChartScene","renderer","chartScenes","s","filter","dispose","fullClearAndRerender","setScissorTest","clear","onScroll","transform","domElement","onResize","clientWidth","clientHeight","needResize","setSize","resizeRendererToDisplaySize","camera","setScissor","setViewport","renderChartScene","initRendering","renderCanvas","WebGLRenderer","alpha","antialias","preserveDrawingBuffer","setClearColor","addEventListener","removeEventListener","push","sceneId","syncCameras","updateViewPort","createWebGLRenderer"],"mappings":"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","file":"static/js/72.ea5856de.chunk.js","sourcesContent":["var CHART_SIZE = {\n    width: 100,\n    height: 100,\n};\nexport { CHART_SIZE as C };\n","import { I as InstancedBufferGeometry, n as numDataPoints, R as RawShaderMaterial, D as DoubleSide, b as InstancedMesh, v as vertices, a as BufferAttribute, c as InstancedBufferAttribute, d as constructChartScene, e as Scene } from './utils-ef59b734.js';\nimport { P as POINT_MESH_INDEX, p as pointMesh, N as NUM_POSITION_COMPONENTS$1, u as updatePointMesh } from './pointMesh-44019046.js';\nimport { c as clipSpaceConversion, n as needsNewClipSpace } from './clipSpaceConversion-2f416caa.js';\nvar lineVert = \"\\nprecision highp float;\\nuniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform float width;\\nuniform float xPixelDensity;\\nuniform float yPixelDensity;\\nattribute vec2 currPoint;\\nattribute vec2 nextPoint;\\nattribute vec2 position;\\nattribute vec3 segmentColor;\\nvarying vec3 vColor;\\n\\n// line shader using instanced lines\\n// https://wwwtyro.net/2019/11/18/instanced-lines.html for information on this approach\\nvoid main() {\\n  // Convert the points to pixel coordinates - otherwise out basis vectors won't be perpendicular when\\n  // rasterized to the screen.\\n  vec2 currPointPx = vec2(currPoint.x / xPixelDensity, currPoint.y / yPixelDensity);\\n  vec2 nextPointPx = vec2(nextPoint.x / xPixelDensity, nextPoint.y / yPixelDensity);\\n\\n  // create the basis vectors of a coordinate space where the x axis is parallel with\\n  // the path between currPoint and nextPoint, and the y axis is perpendicular to the\\n  // path between currPoint and nextPoint\\n  vec2 xBasis = nextPointPx - currPointPx;\\n  vec2 yBasis = normalize(vec2(-xBasis.y, xBasis.x));\\n\\n  // project the instance segment along the basis vectors\\n  vec2 positionPx = currPointPx + xBasis * position.x + yBasis * width * position.y;\\n\\n  // Convert from pixel coordinates back to model space\\n  vec2 positionModel = vec2(positionPx.x * xPixelDensity, positionPx.y * yPixelDensity);\\n\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(positionModel, 0.0, 1.0);\\n  vColor = segmentColor;\\n}\\n\";\nvar lineFrag = \"\\nprecision highp float;\\nvarying vec3 vColor;\\n\\n// Fills in triangles which make up a line segment, with the corresponding color\\nvoid main() {\\n  gl_FragColor = vec4(vColor, 1.0);\\n}\\n\";\n/**\n * Line Chart Settings\n */\nvar STROKE_WIDTH = 1.5;\n/**\n * Get Pixel Density in terms of the clip space\n *\n * Returns the ratio of model space to pixel space in each dimension.\n * i.e. how many pixels does 10 minutes represent on a given `container`?\n */\nvar pixelDensity = function (_a) {\n    var _b = _a.viewPort, end = _b.end, start = _b.start, yMax = _b.yMax, yMin = _b.yMin, toClipSpace = _a.toClipSpace, size = _a.size;\n    var width = size.width, height = size.height;\n    // We must translate our viewport to be in terms of the coordinate system which matches\n    // that of the data being passed in - since we want to know how many pixels\n    // are represented within the webGL context. i.e. clip space pixel density.\n    var x = Math.abs((toClipSpace(end.getTime()) - toClipSpace(start.getTime())) / width);\n    var y = Math.abs((yMax - yMin) / height);\n    return { x: x, y: y };\n};\n/* eslint-disable no-param-reassign */\n/**\n * Create Line Mesh`\n *\n * The representation of the lines between points on a chart.\n */\n// Ensure that the line width is equal to the existing <bp-line-chart />'s line thickness\nvar LINE_WIDTH = STROKE_WIDTH;\nvar LINE_MESH_INDEX = 1;\n// Used to set the default buffer size for a given chart - the larger this is set to, the more memory will be allocated\n// up front per `ChartScene`.\nvar NUM_POSITION_COMPONENTS = 2; // (x, y)\nvar NUM_COLOR_COMPONENTS = 3; // (r, g, b)\nvar numLineSegments = function (streamVertexSets) {\n    var segments = streamVertexSets.reduce(function (totalSegments, streamVertexSet) {\n        // For every point added within a stream, a new segment is drawn,\n        // While there is no visible line segment for the first point added in a stream,\n        // it draws a 'degenerate' segment which is rendered as nothing.\n        // This is purely an implementation detail of the shader, but we must take it into account\n        // when determining the number of 'instances' to be drawn by the instance mesh.\n        // ex1. o--o--o--o  [4 points, 3 visible segments, 1 degenerate segment]\n        // ex2. o           [1 point, 0 visible segments]\n        var streamSegments = Math.max(streamVertexSet.length, 0);\n        return totalSegments + streamSegments;\n    }, 0);\n    return segments;\n};\nvar updateMesh = function (dataStreams, dataStreamInfo, mesh, toClipSpace) {\n    var streamVertexSets = dataStreams.map(function (stream) {\n        var info = dataStreamInfo.find(function (_a) {\n            var id = _a.id;\n            return stream.id === id;\n        });\n        if (info == null) {\n            throw new Error(\"data streams must have an associated data stream info.\\n         missing the data stream info for data stream id: \" + stream.id);\n        }\n        return vertices(stream, info);\n    });\n    // Set the number of instances of the line segment that are to be rendered.\n    mesh.count = numLineSegments(streamVertexSets);\n    var geometry = mesh.geometry;\n    /**\n     * Fill Buffers with data\n     */\n    var _a = geometry.attributes, currPoint = _a.currPoint, nextPoint = _a.nextPoint, segmentColor = _a.segmentColor;\n    var positionIndex = 0;\n    var colorIndex = 0;\n    streamVertexSets.forEach(function (streamVertexSet) {\n        streamVertexSet.forEach(function (currVertex, vertexNum) {\n            var isLastVertex = vertexNum === streamVertexSet.length - 1;\n            var nextVertex = !isLastVertex ? streamVertexSet[vertexNum + 1] : currVertex;\n            var currX = currVertex[0], currY = currVertex[1], r = currVertex[2], g = currVertex[3], b = currVertex[4];\n            var nextX = nextVertex[0], nextY = nextVertex[1];\n            // NOTE: WebGL takes a buffer of values and then converts those to vectors or the correct dimensionality\n            // Set Current Position (currX, currY)\n            currPoint.array[positionIndex] = toClipSpace(currX);\n            currPoint.array[positionIndex + 1] = currY;\n            // Set Next Position (nextX, nextY)\n            nextPoint.array[positionIndex] = toClipSpace(nextX);\n            nextPoint.array[positionIndex + 1] = nextY;\n            // Set Line Segment Color (r, g, b)\n            segmentColor.array[colorIndex] = r;\n            segmentColor.array[colorIndex + 1] = g;\n            segmentColor.array[colorIndex + 2] = b;\n            // Increment Indexes by the associated stride of the buffer\n            colorIndex += NUM_COLOR_COMPONENTS;\n            positionIndex += NUM_POSITION_COMPONENTS;\n        });\n    });\n    currPoint.needsUpdate = true;\n    nextPoint.needsUpdate = true;\n    segmentColor.needsUpdate = true;\n};\n/**\n * Segment Instance Geometry is a square made up of two triangles,\n * as shown in the 'perfect' diagram shown below:\n * (0, 0.5)----(1, 0.5)\n *    |  \\         |\n *    |     \\      |\n *    |         \\  |\n * (0, -0.5)---(1, -0.5)\n */\nvar segmentInstanceGeometry = [[0, -0.5], [1, -0.5], [1, 0.5], [0, -0.5], [1, 0.5], [0, 0.5]];\nvar initializeGeometry = function (geometry, bufferSize) {\n    /**\n     * Create Attributes\n     */\n    geometry.setAttribute('position', new BufferAttribute(new Float32Array(segmentInstanceGeometry.flat()), NUM_POSITION_COMPONENTS));\n    geometry.setAttribute('currPoint', new InstancedBufferAttribute(new Float32Array(bufferSize * NUM_POSITION_COMPONENTS), NUM_POSITION_COMPONENTS, false));\n    geometry.setAttribute('nextPoint', new InstancedBufferAttribute(new Float32Array(bufferSize * NUM_POSITION_COMPONENTS), NUM_POSITION_COMPONENTS, false));\n    geometry.setAttribute('segmentColor', new InstancedBufferAttribute(new Uint8Array(bufferSize * NUM_COLOR_COMPONENTS), NUM_COLOR_COMPONENTS, true));\n};\nvar lineMesh = function (_a) {\n    var viewPort = _a.viewPort, dataStreams = _a.dataStreams, dataStreamInfo = _a.dataStreamInfo, chartSize = _a.chartSize, minBufferSize = _a.minBufferSize, bufferFactor = _a.bufferFactor, toClipSpace = _a.toClipSpace;\n    var geometry = new InstancedBufferGeometry();\n    var bufferSize = Math.max(minBufferSize, numDataPoints(dataStreams) * bufferFactor);\n    // Create and populate geometry\n    initializeGeometry(geometry, bufferSize);\n    // Construct shader\n    var _b = pixelDensity({ viewPort: viewPort, toClipSpace: toClipSpace, size: chartSize }), xPixelDensity = _b.x, yPixelDensity = _b.y;\n    var lineMaterial = new RawShaderMaterial({\n        vertexShader: lineVert,\n        fragmentShader: lineFrag,\n        side: DoubleSide,\n        transparent: true,\n        uniforms: {\n            width: {\n                value: LINE_WIDTH,\n            },\n            xPixelDensity: {\n                value: xPixelDensity,\n            },\n            yPixelDensity: {\n                value: yPixelDensity,\n            },\n        },\n    });\n    var mesh = new InstancedMesh(geometry, lineMaterial, bufferSize);\n    // Prevent bounding sphere from being called\n    mesh.frustumCulled = false;\n    updateMesh(dataStreams, dataStreamInfo, mesh, toClipSpace);\n    return mesh;\n};\nvar updateLineMesh = function (_a) {\n    var chartSize = _a.chartSize, toClipSpace = _a.toClipSpace, lines = _a.lines, dataStreams = _a.dataStreams, dataStreamInfo = _a.dataStreamInfo, viewPort = _a.viewPort, hasDataChanged = _a.hasDataChanged;\n    /**\n     * Update Uniforms\n     */\n    var _b = pixelDensity({ viewPort: viewPort, toClipSpace: toClipSpace, size: chartSize }), xPixelDensity = _b.x, yPixelDensity = _b.y;\n    lines.material.uniforms.xPixelDensity.value = xPixelDensity;\n    lines.material.uniforms.yPixelDensity.value = yPixelDensity;\n    /**\n     * Update Data\n     */\n    if (hasDataChanged) {\n        updateMesh(dataStreams, dataStreamInfo, lines, toClipSpace);\n    }\n};\nvar chartScene = function (_a) {\n    var dataStreams = _a.dataStreams, dataStreamInfo = _a.dataStreamInfo, chartSize = _a.chartSize, container = _a.container, viewPort = _a.viewPort, minBufferSize = _a.minBufferSize, bufferFactor = _a.bufferFactor, onUpdate = _a.onUpdate;\n    var scene = new Scene();\n    var toClipSpace = clipSpaceConversion(viewPort);\n    // Create and add meshes to the chart scene\n    var meshList = [];\n    meshList[LINE_MESH_INDEX] = lineMesh({\n        toClipSpace: toClipSpace,\n        chartSize: chartSize,\n        dataStreams: dataStreams,\n        dataStreamInfo: dataStreamInfo,\n        viewPort: viewPort,\n        minBufferSize: minBufferSize,\n        bufferFactor: bufferFactor,\n    });\n    meshList[POINT_MESH_INDEX] = pointMesh({\n        dataStreams: dataStreams,\n        dataStreamInfo: dataStreamInfo,\n        minBufferSize: minBufferSize,\n        bufferFactor: bufferFactor,\n        toClipSpace: toClipSpace,\n    });\n    meshList.forEach(function (mesh) { return scene.add(mesh); });\n    return constructChartScene({ scene: scene, viewPort: viewPort, container: container, toClipSpace: toClipSpace, onUpdate: onUpdate });\n};\nvar maxDataPointsRendered = function (points) { return points.geometry.attributes.position.array.length / NUM_POSITION_COMPONENTS$1; };\nvar updateChartScene = function (_a) {\n    var scene = _a.scene, dataStreams = _a.dataStreams, chartSize = _a.chartSize, dataStreamInfo = _a.dataStreamInfo, container = _a.container, viewPort = _a.viewPort, hasDataChanged = _a.hasDataChanged, bufferFactor = _a.bufferFactor, minBufferSize = _a.minBufferSize, onUpdate = _a.onUpdate;\n    var lines = scene.scene.children[LINE_MESH_INDEX];\n    var points = scene.scene.children[POINT_MESH_INDEX];\n    // If the amount of data being sent to the chart scene surpasses the size of the buffers within the\n    // chart scene, we must fully recreate the chart scene. This is a costly operation.\n    var isDataOverflowingBuffer = maxDataPointsRendered(points) < numDataPoints(dataStreams);\n    if (isDataOverflowingBuffer || needsNewClipSpace(viewPort, scene.toClipSpace)) {\n        return chartScene({\n            dataStreams: dataStreams,\n            chartSize: chartSize,\n            dataStreamInfo: dataStreamInfo,\n            container: container,\n            viewPort: viewPort,\n            minBufferSize: minBufferSize,\n            bufferFactor: bufferFactor,\n            onUpdate: onUpdate,\n            thresholds: [],\n        });\n    }\n    updateLineMesh({\n        lines: lines,\n        dataStreams: dataStreams,\n        dataStreamInfo: dataStreamInfo,\n        chartSize: chartSize,\n        viewPort: viewPort,\n        hasDataChanged: hasDataChanged,\n        toClipSpace: scene.toClipSpace,\n    });\n    if (hasDataChanged) {\n        updatePointMesh(dataStreams, dataStreamInfo, points, scene.toClipSpace);\n    }\n    // Return existing scene.\n    return scene;\n};\nexport { chartScene as c, updateChartScene as u };\n","import { r as registerInstance, h, g as getElement } from './index-326b73e4.js';\nimport './types-ef93b8eb.js';\nimport './time-cc688558.js';\nimport './_commonjsHelpers-17042db9.js';\nimport './utils-ef59b734.js';\nimport { w as webGLRenderer } from './webglContext-8b607584.js';\nimport './pointMesh-44019046.js';\nimport './v4-1d709f5b.js';\nimport './index-085eab52.js';\nimport './predicates-4851c065.js';\nimport { c as chartScene } from './chartScene-492c5d48.js';\nimport './clipSpaceConversion-2f416caa.js';\nimport { C as CHART_SIZE } from './chartSize-d34de530.js';\n// viewport boundaries\nvar X_MIN = new Date(2000, 0, 0);\nvar X_MAX = new Date(2000, 0, 1);\nvar Y_MIN = 0;\nvar Y_MAX = 100;\nvar WIDTH = X_MAX.getTime() - X_MIN.getTime();\nvar TEST_DATA_POINT_1 = {\n    x: new Date(X_MIN.getTime() + WIDTH / 3),\n    y: (Y_MIN + Y_MAX) / 2,\n};\nvar TEST_DATA_POINT_2 = {\n    x: new Date(X_MIN.getTime() + WIDTH * (2 / 3)),\n    y: (Y_MIN + Y_MAX) / 2,\n};\nvar MonitorStraightLineSegment = /** @class */ (function () {\n    function MonitorStraightLineSegment(hostRef) {\n        registerInstance(this, hostRef);\n    }\n    MonitorStraightLineSegment.prototype.componentDidLoad = function () {\n        var container = this.el.querySelector('#test-container');\n        var scene = chartScene({\n            viewPort: {\n                start: X_MIN,\n                end: X_MAX,\n                yMin: Y_MIN,\n                yMax: Y_MAX,\n            },\n            dataStreams: [\n                {\n                    id: 'test-stream',\n                    data: [TEST_DATA_POINT_1, TEST_DATA_POINT_2],\n                    resolution: 0,\n                },\n            ],\n            dataStreamInfo: [\n                {\n                    id: 'test-stream',\n                    name: 'test-stream-name',\n                    color: 'purple',\n                },\n            ],\n            chartSize: CHART_SIZE,\n            container: container,\n            minBufferSize: 100,\n            bufferFactor: 2,\n            thresholds: [],\n        });\n        webGLRenderer.addChartScene(scene);\n        webGLRenderer.setChartRect(scene.id, container.getBoundingClientRect());\n    };\n    MonitorStraightLineSegment.prototype.render = function () {\n        return (h(\"monitor-webgl-context\", null, h(\"div\", { id: \"test-container\", style: { width: CHART_SIZE.width + \"px\", height: CHART_SIZE.height + \"px\" } })));\n    };\n    Object.defineProperty(MonitorStraightLineSegment.prototype, \"el\", {\n        get: function () { return getElement(this); },\n        enumerable: true,\n        configurable: true\n    });\n    return MonitorStraightLineSegment;\n}());\nexport { MonitorStraightLineSegment as monitor_straight_line_segment_colored };\n","var SECOND_IN_MS = 1000;\nvar MINUTE_IN_MS = 60 * SECOND_IN_MS;\nvar HOUR_IN_MS = 60 * MINUTE_IN_MS;\nvar DAY_IN_MS = 24 * HOUR_IN_MS;\n// Not precisely accurate, only estimates. exact duration depends on start date. use with care.\nvar MONTH_IN_MS = 30 * DAY_IN_MS;\nvar YEAR_IN_MS = 12 * MONTH_IN_MS;\n/**\n * ConvertMS is a helper function that will take in milliseconds and convert it to the highest detonator\n * and does not return the \"remainder\"\n *\n * It is important to note that the object returning does not represent equivalence!\n *\n * For Example:\n * convert(MINUTE_IN_MS) will return:\n * {\n *   day: 0,\n *   hour: 0\n *   minute: 1,\n *   seconds: 0,\n * }\n *\n * IT DOES NOT RETURN:\n *\n * {\n *   day: 0,\n *   hour: 0,\n *   minute: 1,\n *   seconds: 60, <--- does not return the \"equivalence\"\n * }\n */\nvar convertMS = function (milliseconds) {\n    if (milliseconds < 0) {\n        throw new Error('Time cannot be negative!');\n    }\n    var seconds = Math.floor(milliseconds / 1000);\n    var minute = Math.floor(seconds / 60);\n    var hour = Math.floor(minute / 60);\n    var day = Math.floor(hour / 24);\n    seconds %= 60;\n    minute %= 60;\n    hour %= 24;\n    return {\n        day: day,\n        hour: hour,\n        minute: minute,\n        seconds: seconds,\n    };\n};\nvar displayDate = function (date, resolution, _a) {\n    var start = _a.start, end = _a.end;\n    if (resolution < DAY_IN_MS) {\n        var viewPortDurationMS = end.getTime() - start.getTime();\n        if (viewPortDurationMS < MINUTE_IN_MS) {\n            return date.toLocaleString('en-US', {\n                minute: 'numeric',\n                second: 'numeric',\n            });\n        }\n        if (viewPortDurationMS < 10 * MINUTE_IN_MS) {\n            return date.toLocaleString('en-US', {\n                hour: 'numeric',\n                minute: 'numeric',\n                second: 'numeric',\n                hour12: true,\n            });\n        }\n        return date.toLocaleString('en-US', {\n            hour: 'numeric',\n            minute: 'numeric',\n            hour12: true,\n        });\n    }\n    if (resolution <= HOUR_IN_MS) {\n        return date.toLocaleString('en-US', {\n            hour: 'numeric',\n            day: 'long',\n            hour12: true,\n        });\n    }\n    if (resolution <= DAY_IN_MS) {\n        return date.toLocaleString('en-US', {\n            day: 'numeric',\n            month: 'long',\n        });\n    }\n    return date.toLocaleString('en-US', {\n        year: 'numeric',\n        month: 'long',\n    });\n};\nexport { DAY_IN_MS as D, HOUR_IN_MS as H, MINUTE_IN_MS as M, SECOND_IN_MS as S, YEAR_IN_MS as Y, MONTH_IN_MS as a, convertMS as c, displayDate as d };\n","import { M as MINUTE_IN_MS, D as DAY_IN_MS, S as SECOND_IN_MS, Y as YEAR_IN_MS } from './time-cc688558.js';\n/**\n * Clip Space Conversion Utilities\n *\n * Our 'model' space utilizes milliseconds to represent time. This level of granularity is important\n * since we do wish to be able to visually represent the time differences at that level of detail.\n *\n * However, there are 3.15e+10 milliseconds in a year. This is problematic because it means that we cannot represent\n * a years worth of data at the millisecond level granularity utilizing 32 bit floats.\n *\n * double precision is not supported by webGL - there are ways to represent double precision, however these\n * are unnecessarily complicated, double our memory foot print, and actually not necessary.\n *\n * Interesting article on doubles: http://blog.hvidtfeldts.net/index.php/2012/07/double-precision-in-opengl-and-webgl/\n *\n * ## Why Not Necessary To Utilize Doubles?\n *\n * While we need millisecond level precision, we do not need to be able to visually differentiate between milliseconds\n * while looking at even a weeks worth of data. Even if we did, you would not be able to discern a difference\n * due to resolution limitations. Even if you had a hypothetically perfect monitor that could discern a planks-constant\n * level of resolution, the eye would not be able to tell without advanced optical instrumentation!\n *\n * ## Solution\n *\n * We do two things to mitigate - based on the time duration of a given viewport, we will scale down the numbers and\n * truncate the decimals such that the distance from the end to the start of the viewport is representable by a floating point.\n *\n * However, this leaves one more problem - imagine after scaling our viewport in our clip space, we could have\n * our start be 1.20001e+8 to 1.20002e+8, we would have a distance of 1000, which is representable by a 32 bit float, however\n * each number within that range is still not representable by a 32 bit float. To account for this, we also must translate our clip\n * space by what we refer to as an anchor. Suppose we utilize 1.2*10^8 as an anchor, our clip space time range is now 1000 to 2000.\n * Success! We can now represent our time within webgl by a 32 bit float.\n *\n * ## Caveats\n *\n * Since the viewport is dynamic, we have to make sure that as our viewport moves around, we update our `clip space conversion`.\n * Translating, scaling-in, and scaling-out can all cause our `clip space conversion` to start outputting numbers which are not representable by 32 bit floats.\n * To solve this, we also must make sure we watch for viewport changes and adjust our conversion accordingly.\n */\n/**\n * Granularity\n *\n * given a duration, return the granularity in milliseconds.\n * By granularity we mean the minimal time difference which is visually differentiated.\n */\nvar granularity = function (durationMS) {\n    if (durationMS < 10 * MINUTE_IN_MS) {\n        // single millisecond\n        return 1;\n    }\n    if (durationMS < DAY_IN_MS) {\n        return SECOND_IN_MS / 10;\n    }\n    if (durationMS < DAY_IN_MS * 7) {\n        return SECOND_IN_MS;\n    }\n    if (durationMS < YEAR_IN_MS) {\n        return MINUTE_IN_MS;\n    }\n    if (durationMS < 30 * YEAR_IN_MS) {\n        return 30 * MINUTE_IN_MS;\n    }\n    return DAY_IN_MS;\n};\n/**\n * Clip Space Conversion\n *\n * Converts something from model space (millisecond representation of time) into our clip space.\n * The goal is to be able to represent the time from `start` to `end` with floating point precision (7 significant digits).\n */\nvar clipSpaceConversion = function (viewPort) {\n    var durationMS = viewPort.end.getTime() - viewPort.start.getTime();\n    var anchorMS = viewPort.start.getTime() - durationMS * 0.25;\n    var granularityMS = granularity(durationMS);\n    return function (t) { return Math.floor((t - anchorMS) / granularityMS); };\n};\nvar FLOAT_SIG_FIGS = 7;\nvar isDateOutOfBounds = function (date, toClipSpace) { return Math.abs(toClipSpace(date.getTime())) >= Math.pow(10, FLOAT_SIG_FIGS); };\n// Minimum amount of distinct positions our clip spaces needs to represent.\nvar MIN_GRANULARITY = 3000;\n/**\n * Needs New Clip Space\n *\n * There are two conditions which can occur which will require a new clip space.\n *\n * 1. The viewport when mapped to the clip space, contains numbers that aren't representable by floating point precision.\n * 2. The granularity within the viewport mapped to the clip space is too low - i.e. if the viewport maps to [0, 10],\n *    then we can only represent 11 distinct points.\n */\nvar needsNewClipSpace = function (viewPort, toClipSpace) {\n    var isOutOfBounds = isDateOutOfBounds(viewPort.start, toClipSpace) || isDateOutOfBounds(viewPort.end, toClipSpace);\n    var distanceMS = viewPort.end.getTime() - viewPort.start.getTime();\n    var distanceClipSpace = toClipSpace(viewPort.end.getTime()) - toClipSpace(viewPort.start.getTime());\n    var hasTooLowGranularity = distanceMS > distanceClipSpace && distanceClipSpace < MIN_GRANULARITY;\n    return isOutOfBounds || hasTooLowGranularity;\n};\nexport { clipSpaceConversion as c, needsNewClipSpace as n };\n","import { n as numDataPoints, B as BufferGeometry, S as ShaderMaterial, P as Points, v as vertices, a as BufferAttribute } from './utils-ef59b734.js';\nvar shaderVert = \"\\nvarying vec3 vColor;\\nattribute vec3 pointColor;\\nuniform float pointDiameter;\\nuniform float devicePixelRatio;\\n\\nvoid main() {\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x, position.y, 0.0, 1.0);\\n  gl_PointSize = pointDiameter * devicePixelRatio;\\n  vColor = pointColor;\\n}\\n\";\nvar shaderFrag = \"\\nvarying vec3 vColor;\\n\\nvoid main() {\\n  // calculate position such that the center is (0, 0) in a region of [-1, 1] x [-1, 1]\\n  vec2 pos = 2.0 * gl_PointCoord.xy - 1.0;\\n  // r = distance squared from the origin of the point being rendered\\n  float r = dot(pos, pos);\\n  if (r > 1.0) {\\n    discard;\\n  }\\n  float alpha = 1.0 - smoothstep(0.5, 1.0, sqrt(r));\\n  gl_FragColor = vec4(vColor, alpha);\\n}\\n\";\nvar POINT_MESH_INDEX = 0;\nvar POINT_DIAMETER = 6.25;\nvar RAW_POINT_DIAMETER = 4;\n/**\n * Get the diameter of the points to display on the chart.\n *\n * We want to display points smaller for raw data since they may be displayed very densely\n */\nvar pointDiameter = function (dataStreams) {\n    var resolution = dataStreams[0] != null ? dataStreams[0].resolution : null;\n    return resolution === 0 ? RAW_POINT_DIAMETER : POINT_DIAMETER;\n};\n/**\n * Create Point Mesh\n *\n * The representation of the points on a chart.\n */\n// Used to set the default buffer size for a given chart - the larger this is set to, the more memory will be allocated\n// up front per `ChartScene`.\nvar NUM_POSITION_COMPONENTS = 2; // (x, y)\nvar NUM_COLOR_COMPONENTS = 3; // (r, g, b)\n/**\n * Update Geometry\n *\n * Updates the color, and position of the vertices sent down to the vertex shader.\n */\nvar updateGeometry = function (geometry, dataStreams, dataStreamInfo, toClipSpace) {\n    var streamVertexSets = dataStreams.map(function (stream) {\n        var info = dataStreamInfo.find(function (_a) {\n            var id = _a.id;\n            return stream.id === id;\n        });\n        if (info == null) {\n            throw new Error(\"data streams must have an associated data stream info.\\n         missing the data stream info for data stream id: \" + stream.id);\n        }\n        return vertices(stream, info);\n    });\n    var allVertices = streamVertexSets.flat();\n    var _a = geometry.attributes, position = _a.position, pointColor = _a.pointColor;\n    /**\n     * Fill Buffers with data\n     */\n    allVertices.forEach(function (_a, i) {\n        var x = _a[0], y = _a[1], r = _a[2], g = _a[3], b = _a[4];\n        // Set Position\n        position.array[i * NUM_POSITION_COMPONENTS] = toClipSpace(x);\n        position.array[i * NUM_POSITION_COMPONENTS + 1] = y;\n        // Set Normal Data Stream Color\n        pointColor.array[i * NUM_COLOR_COMPONENTS] = r;\n        pointColor.array[i * NUM_COLOR_COMPONENTS + 1] = g;\n        pointColor.array[i * NUM_COLOR_COMPONENTS + 2] = b;\n    });\n    geometry.setDrawRange(0, allVertices.length);\n    position.needsUpdate = true;\n    pointColor.needsUpdate = true;\n};\nvar initializeGeometry = function (geometry, bufferSize) {\n    // TODO(btd): Change to double precision\n    geometry.setAttribute('position', new BufferAttribute(new Float32Array(bufferSize * NUM_POSITION_COMPONENTS), NUM_POSITION_COMPONENTS));\n    geometry.setAttribute('pointColor', new BufferAttribute(new Uint8Array(bufferSize * NUM_COLOR_COMPONENTS), NUM_COLOR_COMPONENTS, true));\n};\n/**\n * Create Point Mesh\n */\nvar pointMesh = function (_a) {\n    var toClipSpace = _a.toClipSpace, dataStreams = _a.dataStreams, dataStreamInfo = _a.dataStreamInfo, minBufferSize = _a.minBufferSize, bufferFactor = _a.bufferFactor;\n    var bufferSize = Math.max(minBufferSize, numDataPoints(dataStreams) * bufferFactor);\n    var geometry = new BufferGeometry();\n    initializeGeometry(geometry, bufferSize);\n    updateGeometry(geometry, dataStreams, dataStreamInfo, toClipSpace);\n    var material = new ShaderMaterial({\n        vertexShader: shaderVert,\n        fragmentShader: shaderFrag,\n        transparent: true,\n        uniforms: {\n            pointDiameter: {\n                value: pointDiameter(dataStreams),\n            },\n            devicePixelRatio: {\n                value: window.devicePixelRatio,\n            },\n        },\n    });\n    var points = new Points(geometry, material);\n    // Prevent computeBoundingSphere from being called\n    points.frustumCulled = false;\n    return points;\n};\n/**\n * Update Point Mesh\n *\n * Updates the point mesh to match the given data stream info and data streams.\n * Increases size of attribute buffers if necessary.\n */\nvar updatePointMesh = function (dataStreams, dataStreamInfo, points, toClipSpace) {\n    // eslint-disable-next-line no-param-reassign\n    points.material.uniforms.pointDiameter.value = pointDiameter(dataStreams);\n    updateGeometry(points.geometry, dataStreams, dataStreamInfo, toClipSpace);\n};\nexport { NUM_POSITION_COMPONENTS as N, POINT_MESH_INDEX as P, pointMesh as p, updatePointMesh as u };\n","import { W as WebGLRenderer } from './utils-ef59b734.js';\n/**\n * Convert a rect to a ClipSpaceRect\n *\n * This will return us the coordinates of a rectangle within clip space coordinates (i.e. coordinate space for webGL)\n * https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection to learn more about clip space\n */\nvar clipSpaceRect = function (containerRect, canvasRect) {\n    var density = window.devicePixelRatio;\n    var left = containerRect.left, bottom = containerRect.bottom, width = containerRect.width, height = containerRect.height;\n    var canvasHeight = canvasRect.height;\n    // The coordinate y-axis is flipped between the DOM and webGL so we must correct for that.\n    // Bounding client rect measures the bottom as the distance from the top, i.e.:\n    // For DOM, (0, 0) is the top left.\n    // In WebGL, (0, 0) is the bottom left.\n    var positiveYUpBottom = canvasHeight - (bottom - window.scrollY);\n    // Need to account for pixel density - i.e. retina display\n    var pixelLeft = (left - window.scrollX) * density;\n    var pixelBottom = positiveYUpBottom * density;\n    var pixelWidth = width * density;\n    var pixelHeight = height * density;\n    return {\n        left: pixelLeft,\n        bottom: pixelBottom,\n        width: pixelWidth,\n        height: pixelHeight,\n    };\n};\n/**\n * Return a rect with the property of being unchanged upon scrolling.\n *\n * The reason this is desirable is because it allows us to not have to re-calculate all our\n * rect's every time a scroll event occurs. This allows for a smooth scroll to occur.\n */\nvar rectScrollFixed = function (el) {\n    var domRect = el.getBoundingClientRect();\n    return {\n        width: domRect.width,\n        height: domRect.height,\n        left: domRect.left + window.scrollX,\n        right: domRect.right + window.scrollX,\n        bottom: domRect.bottom + window.scrollY,\n        top: domRect.top + window.scrollY,\n        x: domRect.x + window.scrollX,\n        y: domRect.y + window.scrollY,\n    };\n};\n/**\n * A map of clip-space rectangles for chart scenes.\n *\n * Allows us to track what region in clip-space each chart scene should be rendered in.\n * The goal is to not have to continually make calls to `getBoundingClientRect` since it is an expsensive operation\n * which causes layouts to be re-calculated: http://dcousineau.com/blog/2013/09/03/high-performance-js-tip/\n */\nvar ClipSpaceRectMap = /** @class */ (function () {\n    function ClipSpaceRectMap(canvas) {\n        this.rectMap = {};\n        this.canvas = canvas;\n        this.updateCanvas();\n    }\n    /**\n     * Update DOMRect for canvas\n     */\n    ClipSpaceRectMap.prototype.updateCanvas = function () {\n        this.canvasRect = this.canvas.getBoundingClientRect();\n    };\n    /**\n     * Updates the rect for the requested chart scene\n     */\n    ClipSpaceRectMap.prototype.updateChartScene = function (chartSceneId, rect) {\n        this.rectMap[chartSceneId] = rect;\n    };\n    /**\n     * Return clip rect for the requested chart scene\n     */\n    ClipSpaceRectMap.prototype.clipRect = function (chartSceneId) {\n        return this.rectMap[chartSceneId] ? clipSpaceRect(this.rectMap[chartSceneId], this.canvasRect) : undefined;\n    };\n    /**\n     * Remove chart scene from rect map\n     */\n    ClipSpaceRectMap.prototype.removeChartScene = function (chartSceneId) {\n        delete this.rectMap[chartSceneId];\n    };\n    return ClipSpaceRectMap;\n}());\n/* eslint-disable @typescript-eslint/no-use-before-define */\n/**\n * Render Scene Info\n *\n * Renders a single chart scene, which will represent a single, rectangular view of data\n * within the shared WebGL context.\n *\n * This technique is inspired by https://threejsfundamentals.org/threejs/lessons/threejs-multiple-scenes.html\n * In summary, each chart scene has an HTML element  - and the associated scene is rendered to overlay on the\n * rectangle defined by the given HTML element.\n */\nvar renderChartScene = function (renderer, _a, _b) {\n    var scene = _a.scene, camera = _a.camera;\n    var left = _b.left, bottom = _b.bottom, width = _b.width, height = _b.height;\n    renderer.setScissor(left, bottom, width, height);\n    renderer.setViewport(left, bottom, width, height);\n    renderer.render(scene, camera);\n};\nfunction resizeRendererToDisplaySize(renderer) {\n    var canvas = renderer.domElement;\n    var width = Math.floor(canvas.clientWidth * window.devicePixelRatio) || 0;\n    var height = Math.floor(canvas.clientHeight * window.devicePixelRatio) || 0;\n    var needResize = canvas.width !== width || canvas.height !== height;\n    if (needResize) {\n        renderer.setSize(width, height, false);\n    }\n    return needResize;\n}\n/**\n * Create a webGL renderer\n *\n * Creates a single webGL rendering context which can be shared across different visualizations.\n * The primary motivator for sharing a single WebGL context is due to the overhead and limitations on making multiple WebGL Context.\n * Resources such as buffered data and textures cannot be shared across WebGL Contexts, and furthermore, due to performance considerations\n * of have many WebGL Contexts, certain browsers have a hard limit on the number of active WebGL Contexts.\n *\n * Refer to https://stackoverflow.com/questions/59140439/allowing-more-webgl-contexts for additional context.\n */\nvar createWebGLRenderer = function () {\n    var rectMap;\n    // List of chart scenes to render in every animation loop.\n    // chart scenes should be mutated to update what gets rendered.\n    var chartScenes = [];\n    /**\n     * Add Chart Scene\n     *\n     * Adds a chart scene to be rendered within the webGL context.\n     * Once added, the given `ChartScene` will be part of the animation loop until explicitly removed.\n     */\n    var addChartScene = function (chartScene) {\n        chartScenes.push(chartScene);\n    };\n    /**\n     * Remove Chart Scene\n     *\n     * Remove and dispose of a given scene.\n     */\n    var removeChartScene = function (chartSceneId) {\n        var chartScene = chartScenes.find(function (s) { return s.id === chartSceneId; });\n        // Remove chart scene from list of registered chart scenes\n        chartScenes = chartScenes.filter(function (s) { return s.id !== chartSceneId; });\n        // Dispose of the chart scene to ensure that the memory is released\n        if (chartScene) {\n            chartScene.dispose();\n        }\n        rectMap.removeChartScene(chartSceneId);\n        fullClearAndRerender();\n    };\n    var syncCameras = function (start, end) {\n        chartScenes.forEach(function (scene) {\n            scene.updateViewPort(start, end);\n            render(scene);\n        });\n    };\n    /**\n     * Initiate Rendering Loop\n     *\n     * Begins a rendering loop to render all chart streams onto the provided canvas\n     */\n    var renderer;\n    var canvas;\n    var fullClearAndRerender = function () {\n        if (renderer) {\n            // Turn off scissor test to make the clear effect the entire canvas\n            renderer.setScissorTest(false);\n            renderer.clear();\n            renderer.setScissorTest(true);\n            // Re-render every chart scene. Necessary since entire canvas has been cleared\n            chartScenes.forEach(render);\n        }\n    };\n    var onScroll = function () {\n        if (renderer && canvas) {\n            var transform = \"translate(\" + window.scrollX + \"px, \" + window.scrollY + \"px)\";\n            // eslint-disable-next-line no-param-reassign\n            renderer.domElement.style.transform = transform;\n            rectMap.updateCanvas();\n            fullClearAndRerender();\n        }\n    };\n    var onResize = function () {\n        if (renderer && canvas) {\n            resizeRendererToDisplaySize(renderer);\n            rectMap.updateCanvas();\n            fullClearAndRerender();\n        }\n    };\n    var initRendering = function (renderCanvas) {\n        rectMap = new ClipSpaceRectMap(renderCanvas);\n        canvas = renderCanvas;\n        renderer = new WebGLRenderer({ canvas: canvas, alpha: true, antialias: true, preserveDrawingBuffer: true });\n        // Enable scissor test, which allows us to render our visualizations to a subset of the canvas\n        // https://threejs.org/docs/#api/en/renderers/WebGLRenderer.setScissor\n        // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/scissor\n        renderer.setScissorTest(true);\n        renderer.setClearColor(0x000000, 0); // transparent clear\n        onScroll();\n        onResize();\n        window.addEventListener('scroll', onScroll);\n        window.addEventListener('resize', onResize);\n    };\n    var render = function (chartScene) {\n        var clipSpaceRect = rectMap.clipRect(chartScene.id);\n        if (renderer && canvas && clipSpaceRect) {\n            renderChartScene(renderer, chartScene, clipSpaceRect);\n        }\n    };\n    var dispose = function () {\n        if (renderer) {\n            chartScenes.map(function (_a) {\n                var id = _a.id;\n                return id;\n            }).forEach(removeChartScene);\n            renderer.dispose();\n        }\n        window.removeEventListener('scroll', onScroll);\n        window.removeEventListener('resize', onResize);\n    };\n    /**\n     * Registers the position and dimension of where the requested chart scene renders to.\n     * Clears the previous renderer location if it exists.\n     */\n    var setChartRect = function (sceneId, rect) {\n        rectMap.updateChartScene(sceneId, rect);\n        fullClearAndRerender();\n    };\n    return {\n        initRendering: initRendering,\n        dispose: dispose,\n        render: render,\n        addChartScene: addChartScene,\n        removeChartScene: removeChartScene,\n        setChartRect: setChartRect,\n        syncCameras: syncCameras,\n    };\n};\n// TODO(btd): Rather than exposing this as a singleton, it would be preferred to expose it as\n//  a shared context within a component sub-tree.\nvar webGLRenderer = createWebGLRenderer();\nexport { rectScrollFixed as r, webGLRenderer as w };\n"],"sourceRoot":""}