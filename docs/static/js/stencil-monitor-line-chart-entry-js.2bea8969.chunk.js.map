{"version":3,"sources":["../node_modules/@amzn/bp-components/dist/esm-es5/chartScene-492c5d48.js","../node_modules/@amzn/bp-components/dist/esm-es5/monitor-line-chart.entry.js","../node_modules/@amzn/bp-components/dist/esm-es5/constants-2dc21ff9.js","../node_modules/@amzn/bp-components/dist/esm-es5/time-cc688558.js","../node_modules/@amzn/bp-components/dist/esm-es5/chartDefaults-5713566e.js","../node_modules/@amzn/bp-components/dist/esm-es5/clipSpaceConversion-2f416caa.js","../node_modules/@amzn/bp-components/dist/esm-es5/pointMesh-44019046.js"],"names":["pixelDensity","_a","_b","viewPort","end","start","yMax","yMin","toClipSpace","size","width","height","x","Math","abs","getTime","y","updateMesh","dataStreams","dataStreamInfo","mesh","streamVertexSets","map","stream","info","find","id","Error","vertices","count","reduce","totalSegments","streamVertexSet","max","length","numLineSegments","geometry","attributes","currPoint","nextPoint","segmentColor","positionIndex","colorIndex","forEach","currVertex","vertexNum","nextVertex","currX","currY","r","g","b","nextX","nextY","array","needsUpdate","segmentInstanceGeometry","lineMesh","chartSize","minBufferSize","bufferFactor","InstancedBufferGeometry","bufferSize","numDataPoints","setAttribute","BufferAttribute","Float32Array","flat","InstancedBufferAttribute","Uint8Array","initializeGeometry","xPixelDensity","yPixelDensity","lineMaterial","RawShaderMaterial","vertexShader","fragmentShader","side","DoubleSide","transparent","uniforms","value","InstancedMesh","frustumCulled","chartScene","container","onUpdate","scene","Scene","clipSpaceConversion","meshList","POINT_MESH_INDEX","pointMesh","add","constructChartScene","updateChartScene","hasDataChanged","lines","children","points","position","NUM_POSITION_COMPONENTS$1","maxDataPointsRendered","needsNewClipSpace","thresholds","material","updateLineMesh","updatePointMesh","MonitorLineChart","hostRef","registerInstance","this","isLoading","isEditing","isFetching","errorMap","prototype","render","_this","h","config","renderFunc","rect","data","annotations","yRange","configId","legend","createChartScene","Object","assign","DEFAULT_CHART_CONFIG","ScaleType","LEGEND_POSITION","SECOND_IN_MS","MINUTE_IN_MS","HOUR_IN_MS","DAY_IN_MS","MONTH_IN_MS","YEAR_IN_MS","convertMS","milliseconds","seconds","floor","minute","hour","day","displayDate","date","resolution","viewPortDurationMS","toLocaleString","second","hour12","month","year","Date","marginLeft","marginRight","marginTop","marginBottom","movement","enableXScroll","enableYScroll","zoomMax","Infinity","zoomMin","layout","xGridVisible","yGridVisible","xTicksVisible","yTicksVisible","scale","xScaleType","TimeSeries","yScaleType","Linear","xScaleSide","yScaleSide","BOTTOM","durationMS","anchorMS","granularityMS","granularity","t","isDateOutOfBounds","pow","isOutOfBounds","distanceMS","distanceClipSpace","pointDiameter","NUM_POSITION_COMPONENTS","updateGeometry","allVertices","pointColor","i","setDrawRange","BufferGeometry","ShaderMaterial","devicePixelRatio","window","Points"],"mappings":"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","file":"static/js/stencil-monitor-line-chart-entry-js.2bea8969.chunk.js","sourcesContent":["import { I as InstancedBufferGeometry, n as numDataPoints, R as RawShaderMaterial, D as DoubleSide, b as InstancedMesh, v as vertices, a as BufferAttribute, c as InstancedBufferAttribute, d as constructChartScene, e as Scene } from './utils-ef59b734.js';\nimport { P as POINT_MESH_INDEX, p as pointMesh, N as NUM_POSITION_COMPONENTS$1, u as updatePointMesh } from './pointMesh-44019046.js';\nimport { c as clipSpaceConversion, n as needsNewClipSpace } from './clipSpaceConversion-2f416caa.js';\nvar lineVert = \"\\nprecision highp float;\\nuniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform float width;\\nuniform float xPixelDensity;\\nuniform float yPixelDensity;\\nattribute vec2 currPoint;\\nattribute vec2 nextPoint;\\nattribute vec2 position;\\nattribute vec3 segmentColor;\\nvarying vec3 vColor;\\n\\n// line shader using instanced lines\\n// https://wwwtyro.net/2019/11/18/instanced-lines.html for information on this approach\\nvoid main() {\\n  // Convert the points to pixel coordinates - otherwise out basis vectors won't be perpendicular when\\n  // rasterized to the screen.\\n  vec2 currPointPx = vec2(currPoint.x / xPixelDensity, currPoint.y / yPixelDensity);\\n  vec2 nextPointPx = vec2(nextPoint.x / xPixelDensity, nextPoint.y / yPixelDensity);\\n\\n  // create the basis vectors of a coordinate space where the x axis is parallel with\\n  // the path between currPoint and nextPoint, and the y axis is perpendicular to the\\n  // path between currPoint and nextPoint\\n  vec2 xBasis = nextPointPx - currPointPx;\\n  vec2 yBasis = normalize(vec2(-xBasis.y, xBasis.x));\\n\\n  // project the instance segment along the basis vectors\\n  vec2 positionPx = currPointPx + xBasis * position.x + yBasis * width * position.y;\\n\\n  // Convert from pixel coordinates back to model space\\n  vec2 positionModel = vec2(positionPx.x * xPixelDensity, positionPx.y * yPixelDensity);\\n\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(positionModel, 0.0, 1.0);\\n  vColor = segmentColor;\\n}\\n\";\nvar lineFrag = \"\\nprecision highp float;\\nvarying vec3 vColor;\\n\\n// Fills in triangles which make up a line segment, with the corresponding color\\nvoid main() {\\n  gl_FragColor = vec4(vColor, 1.0);\\n}\\n\";\n/**\n * Line Chart Settings\n */\nvar STROKE_WIDTH = 1.5;\n/**\n * Get Pixel Density in terms of the clip space\n *\n * Returns the ratio of model space to pixel space in each dimension.\n * i.e. how many pixels does 10 minutes represent on a given `container`?\n */\nvar pixelDensity = function (_a) {\n    var _b = _a.viewPort, end = _b.end, start = _b.start, yMax = _b.yMax, yMin = _b.yMin, toClipSpace = _a.toClipSpace, size = _a.size;\n    var width = size.width, height = size.height;\n    // We must translate our viewport to be in terms of the coordinate system which matches\n    // that of the data being passed in - since we want to know how many pixels\n    // are represented within the webGL context. i.e. clip space pixel density.\n    var x = Math.abs((toClipSpace(end.getTime()) - toClipSpace(start.getTime())) / width);\n    var y = Math.abs((yMax - yMin) / height);\n    return { x: x, y: y };\n};\n/* eslint-disable no-param-reassign */\n/**\n * Create Line Mesh`\n *\n * The representation of the lines between points on a chart.\n */\n// Ensure that the line width is equal to the existing <bp-line-chart />'s line thickness\nvar LINE_WIDTH = STROKE_WIDTH;\nvar LINE_MESH_INDEX = 1;\n// Used to set the default buffer size for a given chart - the larger this is set to, the more memory will be allocated\n// up front per `ChartScene`.\nvar NUM_POSITION_COMPONENTS = 2; // (x, y)\nvar NUM_COLOR_COMPONENTS = 3; // (r, g, b)\nvar numLineSegments = function (streamVertexSets) {\n    var segments = streamVertexSets.reduce(function (totalSegments, streamVertexSet) {\n        // For every point added within a stream, a new segment is drawn,\n        // While there is no visible line segment for the first point added in a stream,\n        // it draws a 'degenerate' segment which is rendered as nothing.\n        // This is purely an implementation detail of the shader, but we must take it into account\n        // when determining the number of 'instances' to be drawn by the instance mesh.\n        // ex1. o--o--o--o  [4 points, 3 visible segments, 1 degenerate segment]\n        // ex2. o           [1 point, 0 visible segments]\n        var streamSegments = Math.max(streamVertexSet.length, 0);\n        return totalSegments + streamSegments;\n    }, 0);\n    return segments;\n};\nvar updateMesh = function (dataStreams, dataStreamInfo, mesh, toClipSpace) {\n    var streamVertexSets = dataStreams.map(function (stream) {\n        var info = dataStreamInfo.find(function (_a) {\n            var id = _a.id;\n            return stream.id === id;\n        });\n        if (info == null) {\n            throw new Error(\"data streams must have an associated data stream info.\\n         missing the data stream info for data stream id: \" + stream.id);\n        }\n        return vertices(stream, info);\n    });\n    // Set the number of instances of the line segment that are to be rendered.\n    mesh.count = numLineSegments(streamVertexSets);\n    var geometry = mesh.geometry;\n    /**\n     * Fill Buffers with data\n     */\n    var _a = geometry.attributes, currPoint = _a.currPoint, nextPoint = _a.nextPoint, segmentColor = _a.segmentColor;\n    var positionIndex = 0;\n    var colorIndex = 0;\n    streamVertexSets.forEach(function (streamVertexSet) {\n        streamVertexSet.forEach(function (currVertex, vertexNum) {\n            var isLastVertex = vertexNum === streamVertexSet.length - 1;\n            var nextVertex = !isLastVertex ? streamVertexSet[vertexNum + 1] : currVertex;\n            var currX = currVertex[0], currY = currVertex[1], r = currVertex[2], g = currVertex[3], b = currVertex[4];\n            var nextX = nextVertex[0], nextY = nextVertex[1];\n            // NOTE: WebGL takes a buffer of values and then converts those to vectors or the correct dimensionality\n            // Set Current Position (currX, currY)\n            currPoint.array[positionIndex] = toClipSpace(currX);\n            currPoint.array[positionIndex + 1] = currY;\n            // Set Next Position (nextX, nextY)\n            nextPoint.array[positionIndex] = toClipSpace(nextX);\n            nextPoint.array[positionIndex + 1] = nextY;\n            // Set Line Segment Color (r, g, b)\n            segmentColor.array[colorIndex] = r;\n            segmentColor.array[colorIndex + 1] = g;\n            segmentColor.array[colorIndex + 2] = b;\n            // Increment Indexes by the associated stride of the buffer\n            colorIndex += NUM_COLOR_COMPONENTS;\n            positionIndex += NUM_POSITION_COMPONENTS;\n        });\n    });\n    currPoint.needsUpdate = true;\n    nextPoint.needsUpdate = true;\n    segmentColor.needsUpdate = true;\n};\n/**\n * Segment Instance Geometry is a square made up of two triangles,\n * as shown in the 'perfect' diagram shown below:\n * (0, 0.5)----(1, 0.5)\n *    |  \\         |\n *    |     \\      |\n *    |         \\  |\n * (0, -0.5)---(1, -0.5)\n */\nvar segmentInstanceGeometry = [[0, -0.5], [1, -0.5], [1, 0.5], [0, -0.5], [1, 0.5], [0, 0.5]];\nvar initializeGeometry = function (geometry, bufferSize) {\n    /**\n     * Create Attributes\n     */\n    geometry.setAttribute('position', new BufferAttribute(new Float32Array(segmentInstanceGeometry.flat()), NUM_POSITION_COMPONENTS));\n    geometry.setAttribute('currPoint', new InstancedBufferAttribute(new Float32Array(bufferSize * NUM_POSITION_COMPONENTS), NUM_POSITION_COMPONENTS, false));\n    geometry.setAttribute('nextPoint', new InstancedBufferAttribute(new Float32Array(bufferSize * NUM_POSITION_COMPONENTS), NUM_POSITION_COMPONENTS, false));\n    geometry.setAttribute('segmentColor', new InstancedBufferAttribute(new Uint8Array(bufferSize * NUM_COLOR_COMPONENTS), NUM_COLOR_COMPONENTS, true));\n};\nvar lineMesh = function (_a) {\n    var viewPort = _a.viewPort, dataStreams = _a.dataStreams, dataStreamInfo = _a.dataStreamInfo, chartSize = _a.chartSize, minBufferSize = _a.minBufferSize, bufferFactor = _a.bufferFactor, toClipSpace = _a.toClipSpace;\n    var geometry = new InstancedBufferGeometry();\n    var bufferSize = Math.max(minBufferSize, numDataPoints(dataStreams) * bufferFactor);\n    // Create and populate geometry\n    initializeGeometry(geometry, bufferSize);\n    // Construct shader\n    var _b = pixelDensity({ viewPort: viewPort, toClipSpace: toClipSpace, size: chartSize }), xPixelDensity = _b.x, yPixelDensity = _b.y;\n    var lineMaterial = new RawShaderMaterial({\n        vertexShader: lineVert,\n        fragmentShader: lineFrag,\n        side: DoubleSide,\n        transparent: true,\n        uniforms: {\n            width: {\n                value: LINE_WIDTH,\n            },\n            xPixelDensity: {\n                value: xPixelDensity,\n            },\n            yPixelDensity: {\n                value: yPixelDensity,\n            },\n        },\n    });\n    var mesh = new InstancedMesh(geometry, lineMaterial, bufferSize);\n    // Prevent bounding sphere from being called\n    mesh.frustumCulled = false;\n    updateMesh(dataStreams, dataStreamInfo, mesh, toClipSpace);\n    return mesh;\n};\nvar updateLineMesh = function (_a) {\n    var chartSize = _a.chartSize, toClipSpace = _a.toClipSpace, lines = _a.lines, dataStreams = _a.dataStreams, dataStreamInfo = _a.dataStreamInfo, viewPort = _a.viewPort, hasDataChanged = _a.hasDataChanged;\n    /**\n     * Update Uniforms\n     */\n    var _b = pixelDensity({ viewPort: viewPort, toClipSpace: toClipSpace, size: chartSize }), xPixelDensity = _b.x, yPixelDensity = _b.y;\n    lines.material.uniforms.xPixelDensity.value = xPixelDensity;\n    lines.material.uniforms.yPixelDensity.value = yPixelDensity;\n    /**\n     * Update Data\n     */\n    if (hasDataChanged) {\n        updateMesh(dataStreams, dataStreamInfo, lines, toClipSpace);\n    }\n};\nvar chartScene = function (_a) {\n    var dataStreams = _a.dataStreams, dataStreamInfo = _a.dataStreamInfo, chartSize = _a.chartSize, container = _a.container, viewPort = _a.viewPort, minBufferSize = _a.minBufferSize, bufferFactor = _a.bufferFactor, onUpdate = _a.onUpdate;\n    var scene = new Scene();\n    var toClipSpace = clipSpaceConversion(viewPort);\n    // Create and add meshes to the chart scene\n    var meshList = [];\n    meshList[LINE_MESH_INDEX] = lineMesh({\n        toClipSpace: toClipSpace,\n        chartSize: chartSize,\n        dataStreams: dataStreams,\n        dataStreamInfo: dataStreamInfo,\n        viewPort: viewPort,\n        minBufferSize: minBufferSize,\n        bufferFactor: bufferFactor,\n    });\n    meshList[POINT_MESH_INDEX] = pointMesh({\n        dataStreams: dataStreams,\n        dataStreamInfo: dataStreamInfo,\n        minBufferSize: minBufferSize,\n        bufferFactor: bufferFactor,\n        toClipSpace: toClipSpace,\n    });\n    meshList.forEach(function (mesh) { return scene.add(mesh); });\n    return constructChartScene({ scene: scene, viewPort: viewPort, container: container, toClipSpace: toClipSpace, onUpdate: onUpdate });\n};\nvar maxDataPointsRendered = function (points) { return points.geometry.attributes.position.array.length / NUM_POSITION_COMPONENTS$1; };\nvar updateChartScene = function (_a) {\n    var scene = _a.scene, dataStreams = _a.dataStreams, chartSize = _a.chartSize, dataStreamInfo = _a.dataStreamInfo, container = _a.container, viewPort = _a.viewPort, hasDataChanged = _a.hasDataChanged, bufferFactor = _a.bufferFactor, minBufferSize = _a.minBufferSize, onUpdate = _a.onUpdate;\n    var lines = scene.scene.children[LINE_MESH_INDEX];\n    var points = scene.scene.children[POINT_MESH_INDEX];\n    // If the amount of data being sent to the chart scene surpasses the size of the buffers within the\n    // chart scene, we must fully recreate the chart scene. This is a costly operation.\n    var isDataOverflowingBuffer = maxDataPointsRendered(points) < numDataPoints(dataStreams);\n    if (isDataOverflowingBuffer || needsNewClipSpace(viewPort, scene.toClipSpace)) {\n        return chartScene({\n            dataStreams: dataStreams,\n            chartSize: chartSize,\n            dataStreamInfo: dataStreamInfo,\n            container: container,\n            viewPort: viewPort,\n            minBufferSize: minBufferSize,\n            bufferFactor: bufferFactor,\n            onUpdate: onUpdate,\n            thresholds: [],\n        });\n    }\n    updateLineMesh({\n        lines: lines,\n        dataStreams: dataStreams,\n        dataStreamInfo: dataStreamInfo,\n        chartSize: chartSize,\n        viewPort: viewPort,\n        hasDataChanged: hasDataChanged,\n        toClipSpace: scene.toClipSpace,\n    });\n    if (hasDataChanged) {\n        updatePointMesh(dataStreams, dataStreamInfo, points, scene.toClipSpace);\n    }\n    // Return existing scene.\n    return scene;\n};\nexport { chartScene as c, updateChartScene as u };\n","import { r as registerInstance, h } from './index-326b73e4.js';\nimport './types-ef93b8eb.js';\nimport './constants-2dc21ff9.js';\nimport './time-cc688558.js';\nimport './_commonjsHelpers-17042db9.js';\nimport { D as DEFAULT_CHART_CONFIG } from './chartDefaults-5713566e.js';\nimport './utils-ef59b734.js';\nimport './pointMesh-44019046.js';\nimport './v4-1d709f5b.js';\nimport './index-085eab52.js';\nimport './predicates-4851c065.js';\nimport { u as updateChartScene, c as chartScene } from './chartScene-492c5d48.js';\nimport './clipSpaceConversion-2f416caa.js';\n// The initial size of buffers. The larger this is, the more memory allocated up front per chart.\n// The lower this number is, more likely that charts will have to re-initialize there buffers which is\n// a slow operation (CPU bound).\nvar DEFAULT_MIN_BUFFER_SIZE = 1000;\nvar DEFAULT_BUFFER_FACTOR = 2;\nvar MonitorLineChart = /** @class */ (function () {\n    function MonitorLineChart(hostRef) {\n        registerInstance(this, hostRef);\n        this.isLoading = false;\n        this.isEditing = false;\n        this.isFetching = false;\n        this.errorMap = {};\n        this.bufferFactor = DEFAULT_BUFFER_FACTOR;\n        this.minBufferSize = DEFAULT_MIN_BUFFER_SIZE;\n    }\n    MonitorLineChart.prototype.render = function () {\n        var _this = this;\n        return (h(\"monitor-size-provider\", { size: this.config.size, renderFunc: function (rect) { return (h(\"monitor-viewport-provider\", { dataStreams: _this.data, config: _this.config, annotations: _this.annotations, renderFunc: function (yRange) { return (h(\"monitor-webgl-base-chart\", { configId: _this.config.id, legend: _this.config.legend, annotations: _this.annotations, updateChartScene: updateChartScene, createChartScene: chartScene, dataStreamInfo: _this.config.dataStreamInfo, errorMap: _this.errorMap, size: Object.assign(Object.assign(Object.assign({}, DEFAULT_CHART_CONFIG.size), _this.config.size), rect), data: _this.data, viewPort: Object.assign(Object.assign({}, _this.config.viewPort), yRange), minBufferSize: _this.minBufferSize, bufferFactor: _this.bufferFactor, isEditing: _this.isEditing, isFetching: _this.isFetching, isLoading: _this.isLoading })); } })); } }));\n    };\n    return MonitorLineChart;\n}());\nexport { MonitorLineChart as monitor_line_chart };\n","// NOTE: `enum`s are held separately from the types which are exported\n// as part of the package, since `enum`'s cannot be present in a type declaration file.\n// THis is due to an `enum` being a type plus an implementation, while type declaration\n// files can only contain typing information.\n/**\n * Maps the view model to d3 axis types. In the future we could add additional\n * custom scale types beyond what's available in `d3-axis`.\n */\nvar ScaleType;\n(function (ScaleType) {\n    ScaleType[\"TimeSeries\"] = \"time-series\";\n    ScaleType[\"Log\"] = \"log\";\n    ScaleType[\"Linear\"] = \"linear\";\n})(ScaleType || (ScaleType = {}));\nvar LEGEND_POSITION;\n(function (LEGEND_POSITION) {\n    LEGEND_POSITION[\"RIGHT\"] = \"RIGHT\";\n    LEGEND_POSITION[\"BOTTOM\"] = \"BOTTOM\";\n})(LEGEND_POSITION || (LEGEND_POSITION = {}));\nexport { LEGEND_POSITION as L, ScaleType as S };\n","var SECOND_IN_MS = 1000;\nvar MINUTE_IN_MS = 60 * SECOND_IN_MS;\nvar HOUR_IN_MS = 60 * MINUTE_IN_MS;\nvar DAY_IN_MS = 24 * HOUR_IN_MS;\n// Not precisely accurate, only estimates. exact duration depends on start date. use with care.\nvar MONTH_IN_MS = 30 * DAY_IN_MS;\nvar YEAR_IN_MS = 12 * MONTH_IN_MS;\n/**\n * ConvertMS is a helper function that will take in milliseconds and convert it to the highest detonator\n * and does not return the \"remainder\"\n *\n * It is important to note that the object returning does not represent equivalence!\n *\n * For Example:\n * convert(MINUTE_IN_MS) will return:\n * {\n *   day: 0,\n *   hour: 0\n *   minute: 1,\n *   seconds: 0,\n * }\n *\n * IT DOES NOT RETURN:\n *\n * {\n *   day: 0,\n *   hour: 0,\n *   minute: 1,\n *   seconds: 60, <--- does not return the \"equivalence\"\n * }\n */\nvar convertMS = function (milliseconds) {\n    if (milliseconds < 0) {\n        throw new Error('Time cannot be negative!');\n    }\n    var seconds = Math.floor(milliseconds / 1000);\n    var minute = Math.floor(seconds / 60);\n    var hour = Math.floor(minute / 60);\n    var day = Math.floor(hour / 24);\n    seconds %= 60;\n    minute %= 60;\n    hour %= 24;\n    return {\n        day: day,\n        hour: hour,\n        minute: minute,\n        seconds: seconds,\n    };\n};\nvar displayDate = function (date, resolution, _a) {\n    var start = _a.start, end = _a.end;\n    if (resolution < DAY_IN_MS) {\n        var viewPortDurationMS = end.getTime() - start.getTime();\n        if (viewPortDurationMS < MINUTE_IN_MS) {\n            return date.toLocaleString('en-US', {\n                minute: 'numeric',\n                second: 'numeric',\n            });\n        }\n        if (viewPortDurationMS < 10 * MINUTE_IN_MS) {\n            return date.toLocaleString('en-US', {\n                hour: 'numeric',\n                minute: 'numeric',\n                second: 'numeric',\n                hour12: true,\n            });\n        }\n        return date.toLocaleString('en-US', {\n            hour: 'numeric',\n            minute: 'numeric',\n            hour12: true,\n        });\n    }\n    if (resolution <= HOUR_IN_MS) {\n        return date.toLocaleString('en-US', {\n            hour: 'numeric',\n            day: 'long',\n            hour12: true,\n        });\n    }\n    if (resolution <= DAY_IN_MS) {\n        return date.toLocaleString('en-US', {\n            day: 'numeric',\n            month: 'long',\n        });\n    }\n    return date.toLocaleString('en-US', {\n        year: 'numeric',\n        month: 'long',\n    });\n};\nexport { DAY_IN_MS as D, HOUR_IN_MS as H, MINUTE_IN_MS as M, SECOND_IN_MS as S, YEAR_IN_MS as Y, MONTH_IN_MS as a, convertMS as c, displayDate as d };\n","import { S as ScaleType, L as LEGEND_POSITION } from './constants-2dc21ff9.js';\nvar DEFAULT_CHART_CONFIG = {\n    id: 'fake-id',\n    viewPort: {\n        start: new Date(1995, 0, 0, 0),\n        end: new Date(2020, 1, 0, 0),\n        yMin: 0,\n        yMax: 10000,\n    },\n    // width is width - marginLeft - marginRight\n    size: { width: 400 + 50 + 25, height: 350, marginLeft: 50, marginRight: 50, marginTop: 8, marginBottom: 30 },\n    movement: {\n        enableXScroll: true,\n        enableYScroll: false,\n        zoomMax: Infinity,\n        zoomMin: 0.00001,\n    },\n    layout: {\n        xGridVisible: false,\n        yGridVisible: true,\n        xTicksVisible: true,\n        yTicksVisible: true,\n    },\n    scale: {\n        xScaleType: ScaleType.TimeSeries,\n        yScaleType: ScaleType.Linear,\n        xScaleSide: 'bottom',\n        yScaleSide: 'left',\n    },\n    dataStreamInfo: [],\n    legend: {\n        position: LEGEND_POSITION.BOTTOM,\n        width: 180,\n    },\n};\nexport { DEFAULT_CHART_CONFIG as D };\n","import { M as MINUTE_IN_MS, D as DAY_IN_MS, S as SECOND_IN_MS, Y as YEAR_IN_MS } from './time-cc688558.js';\n/**\n * Clip Space Conversion Utilities\n *\n * Our 'model' space utilizes milliseconds to represent time. This level of granularity is important\n * since we do wish to be able to visually represent the time differences at that level of detail.\n *\n * However, there are 3.15e+10 milliseconds in a year. This is problematic because it means that we cannot represent\n * a years worth of data at the millisecond level granularity utilizing 32 bit floats.\n *\n * double precision is not supported by webGL - there are ways to represent double precision, however these\n * are unnecessarily complicated, double our memory foot print, and actually not necessary.\n *\n * Interesting article on doubles: http://blog.hvidtfeldts.net/index.php/2012/07/double-precision-in-opengl-and-webgl/\n *\n * ## Why Not Necessary To Utilize Doubles?\n *\n * While we need millisecond level precision, we do not need to be able to visually differentiate between milliseconds\n * while looking at even a weeks worth of data. Even if we did, you would not be able to discern a difference\n * due to resolution limitations. Even if you had a hypothetically perfect monitor that could discern a planks-constant\n * level of resolution, the eye would not be able to tell without advanced optical instrumentation!\n *\n * ## Solution\n *\n * We do two things to mitigate - based on the time duration of a given viewport, we will scale down the numbers and\n * truncate the decimals such that the distance from the end to the start of the viewport is representable by a floating point.\n *\n * However, this leaves one more problem - imagine after scaling our viewport in our clip space, we could have\n * our start be 1.20001e+8 to 1.20002e+8, we would have a distance of 1000, which is representable by a 32 bit float, however\n * each number within that range is still not representable by a 32 bit float. To account for this, we also must translate our clip\n * space by what we refer to as an anchor. Suppose we utilize 1.2*10^8 as an anchor, our clip space time range is now 1000 to 2000.\n * Success! We can now represent our time within webgl by a 32 bit float.\n *\n * ## Caveats\n *\n * Since the viewport is dynamic, we have to make sure that as our viewport moves around, we update our `clip space conversion`.\n * Translating, scaling-in, and scaling-out can all cause our `clip space conversion` to start outputting numbers which are not representable by 32 bit floats.\n * To solve this, we also must make sure we watch for viewport changes and adjust our conversion accordingly.\n */\n/**\n * Granularity\n *\n * given a duration, return the granularity in milliseconds.\n * By granularity we mean the minimal time difference which is visually differentiated.\n */\nvar granularity = function (durationMS) {\n    if (durationMS < 10 * MINUTE_IN_MS) {\n        // single millisecond\n        return 1;\n    }\n    if (durationMS < DAY_IN_MS) {\n        return SECOND_IN_MS / 10;\n    }\n    if (durationMS < DAY_IN_MS * 7) {\n        return SECOND_IN_MS;\n    }\n    if (durationMS < YEAR_IN_MS) {\n        return MINUTE_IN_MS;\n    }\n    if (durationMS < 30 * YEAR_IN_MS) {\n        return 30 * MINUTE_IN_MS;\n    }\n    return DAY_IN_MS;\n};\n/**\n * Clip Space Conversion\n *\n * Converts something from model space (millisecond representation of time) into our clip space.\n * The goal is to be able to represent the time from `start` to `end` with floating point precision (7 significant digits).\n */\nvar clipSpaceConversion = function (viewPort) {\n    var durationMS = viewPort.end.getTime() - viewPort.start.getTime();\n    var anchorMS = viewPort.start.getTime() - durationMS * 0.25;\n    var granularityMS = granularity(durationMS);\n    return function (t) { return Math.floor((t - anchorMS) / granularityMS); };\n};\nvar FLOAT_SIG_FIGS = 7;\nvar isDateOutOfBounds = function (date, toClipSpace) { return Math.abs(toClipSpace(date.getTime())) >= Math.pow(10, FLOAT_SIG_FIGS); };\n// Minimum amount of distinct positions our clip spaces needs to represent.\nvar MIN_GRANULARITY = 3000;\n/**\n * Needs New Clip Space\n *\n * There are two conditions which can occur which will require a new clip space.\n *\n * 1. The viewport when mapped to the clip space, contains numbers that aren't representable by floating point precision.\n * 2. The granularity within the viewport mapped to the clip space is too low - i.e. if the viewport maps to [0, 10],\n *    then we can only represent 11 distinct points.\n */\nvar needsNewClipSpace = function (viewPort, toClipSpace) {\n    var isOutOfBounds = isDateOutOfBounds(viewPort.start, toClipSpace) || isDateOutOfBounds(viewPort.end, toClipSpace);\n    var distanceMS = viewPort.end.getTime() - viewPort.start.getTime();\n    var distanceClipSpace = toClipSpace(viewPort.end.getTime()) - toClipSpace(viewPort.start.getTime());\n    var hasTooLowGranularity = distanceMS > distanceClipSpace && distanceClipSpace < MIN_GRANULARITY;\n    return isOutOfBounds || hasTooLowGranularity;\n};\nexport { clipSpaceConversion as c, needsNewClipSpace as n };\n","import { n as numDataPoints, B as BufferGeometry, S as ShaderMaterial, P as Points, v as vertices, a as BufferAttribute } from './utils-ef59b734.js';\nvar shaderVert = \"\\nvarying vec3 vColor;\\nattribute vec3 pointColor;\\nuniform float pointDiameter;\\nuniform float devicePixelRatio;\\n\\nvoid main() {\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x, position.y, 0.0, 1.0);\\n  gl_PointSize = pointDiameter * devicePixelRatio;\\n  vColor = pointColor;\\n}\\n\";\nvar shaderFrag = \"\\nvarying vec3 vColor;\\n\\nvoid main() {\\n  // calculate position such that the center is (0, 0) in a region of [-1, 1] x [-1, 1]\\n  vec2 pos = 2.0 * gl_PointCoord.xy - 1.0;\\n  // r = distance squared from the origin of the point being rendered\\n  float r = dot(pos, pos);\\n  if (r > 1.0) {\\n    discard;\\n  }\\n  float alpha = 1.0 - smoothstep(0.5, 1.0, sqrt(r));\\n  gl_FragColor = vec4(vColor, alpha);\\n}\\n\";\nvar POINT_MESH_INDEX = 0;\nvar POINT_DIAMETER = 6.25;\nvar RAW_POINT_DIAMETER = 4;\n/**\n * Get the diameter of the points to display on the chart.\n *\n * We want to display points smaller for raw data since they may be displayed very densely\n */\nvar pointDiameter = function (dataStreams) {\n    var resolution = dataStreams[0] != null ? dataStreams[0].resolution : null;\n    return resolution === 0 ? RAW_POINT_DIAMETER : POINT_DIAMETER;\n};\n/**\n * Create Point Mesh\n *\n * The representation of the points on a chart.\n */\n// Used to set the default buffer size for a given chart - the larger this is set to, the more memory will be allocated\n// up front per `ChartScene`.\nvar NUM_POSITION_COMPONENTS = 2; // (x, y)\nvar NUM_COLOR_COMPONENTS = 3; // (r, g, b)\n/**\n * Update Geometry\n *\n * Updates the color, and position of the vertices sent down to the vertex shader.\n */\nvar updateGeometry = function (geometry, dataStreams, dataStreamInfo, toClipSpace) {\n    var streamVertexSets = dataStreams.map(function (stream) {\n        var info = dataStreamInfo.find(function (_a) {\n            var id = _a.id;\n            return stream.id === id;\n        });\n        if (info == null) {\n            throw new Error(\"data streams must have an associated data stream info.\\n         missing the data stream info for data stream id: \" + stream.id);\n        }\n        return vertices(stream, info);\n    });\n    var allVertices = streamVertexSets.flat();\n    var _a = geometry.attributes, position = _a.position, pointColor = _a.pointColor;\n    /**\n     * Fill Buffers with data\n     */\n    allVertices.forEach(function (_a, i) {\n        var x = _a[0], y = _a[1], r = _a[2], g = _a[3], b = _a[4];\n        // Set Position\n        position.array[i * NUM_POSITION_COMPONENTS] = toClipSpace(x);\n        position.array[i * NUM_POSITION_COMPONENTS + 1] = y;\n        // Set Normal Data Stream Color\n        pointColor.array[i * NUM_COLOR_COMPONENTS] = r;\n        pointColor.array[i * NUM_COLOR_COMPONENTS + 1] = g;\n        pointColor.array[i * NUM_COLOR_COMPONENTS + 2] = b;\n    });\n    geometry.setDrawRange(0, allVertices.length);\n    position.needsUpdate = true;\n    pointColor.needsUpdate = true;\n};\nvar initializeGeometry = function (geometry, bufferSize) {\n    // TODO(btd): Change to double precision\n    geometry.setAttribute('position', new BufferAttribute(new Float32Array(bufferSize * NUM_POSITION_COMPONENTS), NUM_POSITION_COMPONENTS));\n    geometry.setAttribute('pointColor', new BufferAttribute(new Uint8Array(bufferSize * NUM_COLOR_COMPONENTS), NUM_COLOR_COMPONENTS, true));\n};\n/**\n * Create Point Mesh\n */\nvar pointMesh = function (_a) {\n    var toClipSpace = _a.toClipSpace, dataStreams = _a.dataStreams, dataStreamInfo = _a.dataStreamInfo, minBufferSize = _a.minBufferSize, bufferFactor = _a.bufferFactor;\n    var bufferSize = Math.max(minBufferSize, numDataPoints(dataStreams) * bufferFactor);\n    var geometry = new BufferGeometry();\n    initializeGeometry(geometry, bufferSize);\n    updateGeometry(geometry, dataStreams, dataStreamInfo, toClipSpace);\n    var material = new ShaderMaterial({\n        vertexShader: shaderVert,\n        fragmentShader: shaderFrag,\n        transparent: true,\n        uniforms: {\n            pointDiameter: {\n                value: pointDiameter(dataStreams),\n            },\n            devicePixelRatio: {\n                value: window.devicePixelRatio,\n            },\n        },\n    });\n    var points = new Points(geometry, material);\n    // Prevent computeBoundingSphere from being called\n    points.frustumCulled = false;\n    return points;\n};\n/**\n * Update Point Mesh\n *\n * Updates the point mesh to match the given data stream info and data streams.\n * Increases size of attribute buffers if necessary.\n */\nvar updatePointMesh = function (dataStreams, dataStreamInfo, points, toClipSpace) {\n    // eslint-disable-next-line no-param-reassign\n    points.material.uniforms.pointDiameter.value = pointDiameter(dataStreams);\n    updateGeometry(points.geometry, dataStreams, dataStreamInfo, toClipSpace);\n};\nexport { NUM_POSITION_COMPONENTS as N, POINT_MESH_INDEX as P, pointMesh as p, updatePointMesh as u };\n"],"sourceRoot":""}