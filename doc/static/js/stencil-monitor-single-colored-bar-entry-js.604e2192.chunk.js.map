{"version":3,"sources":["../node_modules/@amzn/bp-components/dist/esm-es5/chartSize-d34de530.js","../node_modules/@amzn/bp-components/dist/esm-es5/chartScene-551b2a63.js","../node_modules/@amzn/bp-components/dist/esm-es5/monitor-single-colored-bar.entry.js","../node_modules/@amzn/bp-components/dist/esm-es5/time-cc688558.js","../node_modules/@amzn/bp-components/dist/esm-es5/clipSpaceConversion-2f416caa.js","../node_modules/@amzn/bp-components/dist/esm-es5/webglContext-8b607584.js"],"names":["CHART_SIZE","width","height","getDistanceFromDuration","toClipSpace","milliseconds","Math","abs","Date","getTime","getBarWidth","_a","resolution","numDataStreams","getBarMargin","getUniformWidth","dataStreams","length","updateMesh","dataStreamInfo","mesh","streamVertexSets","map","stream","info","find","id","Error","vertices","count","reduce","totalBars","streamVertexSet","max","numBars","_b","geometry","attributes","color","bar","positionIndex","colorIndex","forEach","setIndex","currVertex","currX","currY","r","g","b","array","needsUpdate","unitSquare","barMesh","bufferFactor","minBufferSize","instGeo","InstancedBufferGeometry","bufferSize","numDataPoints","setAttribute","BufferAttribute","Float32Array","InstancedBufferAttribute","Uint8Array","initializeGeometry","barChartMaterial","RawShaderMaterial","vertexShader","fragmentShader","side","DoubleSide","transparent","uniforms","value","InstancedMesh","frustumCulled","chartScene","container","viewPort","scene","Scene","clipSpaceConversion","add","constructChartScene","updateChartScene","hasDataChanged","chartSize","bars","children","maxDataPointsRendered","needsNewClipSpace","thresholds","material","updateBarMesh","X_MIN","X_MAX","WIDTH","TEST_DATA_POINT_1","x","y","Y_MIN","MonitorSingleColoredBar","hostRef","registerInstance","this","prototype","componentDidLoad","el","querySelector","start","end","yMin","yMax","data","DAY_IN_MS","name","webGLRenderer","addChartScene","setChartRect","getBoundingClientRect","render","h","style","Object","defineProperty","get","getElement","enumerable","configurable","SECOND_IN_MS","MINUTE_IN_MS","HOUR_IN_MS","MONTH_IN_MS","YEAR_IN_MS","convertMS","seconds","floor","minute","hour","day","displayDate","date","viewPortDurationMS","toLocaleString","second","hour12","month","year","durationMS","anchorMS","granularityMS","granularity","t","isDateOutOfBounds","pow","isOutOfBounds","distanceMS","distanceClipSpace","rectScrollFixed","domRect","left","window","scrollX","right","bottom","scrollY","top","ClipSpaceRectMap","canvas","rectMap","updateCanvas","canvasRect","chartSceneId","rect","clipRect","containerRect","density","devicePixelRatio","positiveYUpBottom","clipSpaceRect","undefined","removeChartScene","renderer","chartScenes","s","filter","dispose","fullClearAndRerender","setScissorTest","clear","onScroll","transform","domElement","onResize","clientWidth","clientHeight","needResize","setSize","resizeRendererToDisplaySize","camera","setScissor","setViewport","renderChartScene","initRendering","renderCanvas","WebGLRenderer","alpha","antialias","preserveDrawingBuffer","setClearColor","addEventListener","removeEventListener","push","sceneId","syncCameras","updateViewPort","createWebGLRenderer"],"mappings":"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","file":"static/js/stencil-monitor-single-colored-bar-entry-js.604e2192.chunk.js","sourcesContent":["var CHART_SIZE = {\n    width: 100,\n    height: 100,\n};\nexport { CHART_SIZE as C };\n","import { I as InstancedBufferGeometry, n as numDataPoints, R as RawShaderMaterial, D as DoubleSide, b as InstancedMesh, v as vertices, a as BufferAttribute, c as InstancedBufferAttribute, d as constructChartScene, e as Scene } from './utils-ef59b734.js';\nimport { c as clipSpaceConversion, n as needsNewClipSpace } from './clipSpaceConversion-2f416caa.js';\n/* eslint-disable max-len */\nvar barVert = \"\\nprecision highp float;\\nuniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform float width;\\nattribute vec2 bar;\\nattribute vec2 position;\\nattribute vec3 color;\\nvarying vec3 vColor;\\n\\nvoid main() {\\n  // Negative width here because we want to render the bars' width to the left side starting from its x position.\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x * -width + bar.x, position.y * bar.y, 0.0, 1.0);\\n  vColor = color;\\n}\\n\";\nvar barFrag = \"\\nprecision highp float;\\nvarying vec3 vColor;\\n\\nvoid main() {\\n  gl_FragColor = vec4(vColor, 1.0);\\n}\\n\";\n/**\n * Display Constants\n *\n * Adjust these to scale the margins provided within the bar chart.\n * This represent which fraction of the 'width' of a given bar group a margin.\n */\nvar MARGIN_FACTOR = 1 / 6;\n/**\n *\n * Get Distance from Duration\n *\n * Return distance between `milliseconds` on a given `xScale`, assuming `xScale` is linear.\n * If `xScale` is not linear, the distance between two points can depend on the exact value of time,\n * rather than just the time between. Non-linear `xScale` requires the width to be computed for every point rather\n * than just once.\n *\n * Since a non-linear xAxis is an un-common use case we won't support that for now.\n */\nvar getDistanceFromDuration = function (toClipSpace, milliseconds) { return Math.abs(toClipSpace(new Date(milliseconds).getTime()) - toClipSpace(new Date(0).getTime())); };\nvar getBarMargin = function (toClipSpace, resolution) { return getDistanceFromDuration(toClipSpace, resolution * MARGIN_FACTOR); };\n/**\n * Get the bar width\n *\n * Returns the clipSpace width which each bar should be.\n * It is assumed that each bar within a group will have the same width.\n */\nvar getBarWidth = function (_a) {\n    var toClipSpace = _a.toClipSpace, resolution = _a.resolution, numDataStreams = _a.numDataStreams;\n    return (getDistanceFromDuration(toClipSpace, resolution) - getBarMargin(toClipSpace, resolution)) / numDataStreams;\n};\n// Used to set the default buffer size for a given chart - the larger this is set to, the more memory will be allocated\n// up front per `ChartScene`.\nvar NUM_POSITION_COMPONENTS = 2; // (x, y)\nvar NUM_COLOR_COMPONENTS = 3; // (r, g, b)\nvar numBars = function (streamVertexSets) {\n    var bars = streamVertexSets.reduce(function (totalBars, streamVertexSet) {\n        var streamBars = Math.max(streamVertexSet.length, 0);\n        return totalBars + streamBars;\n    }, 0);\n    return bars;\n};\nvar getUniformWidth = function (dataStreams, toClipSpace) {\n    if (dataStreams.length === 0) {\n        return 0;\n    }\n    var resolution = dataStreams[0].resolution;\n    return getBarWidth({\n        toClipSpace: toClipSpace,\n        numDataStreams: dataStreams.length,\n        resolution: resolution,\n    });\n};\nvar updateMesh = function (_a) {\n    var dataStreams = _a.dataStreams, dataStreamInfo = _a.dataStreamInfo, mesh = _a.mesh, toClipSpace = _a.toClipSpace;\n    var streamVertexSets = dataStreams.map(function (stream) {\n        var info = dataStreamInfo.find(function (_a) {\n            var id = _a.id;\n            return stream.id === id;\n        });\n        if (info == null) {\n            throw new Error(\"data streams must have an associated data stream info.\\n         missing the data stream info for data stream id: \" + stream.id);\n        }\n        return vertices(stream, info);\n    });\n    // Set the number of instances of the bar are to be rendered.\n    // eslint-disable-next-line no-param-reassign\n    mesh.count = numBars(streamVertexSets);\n    var geometry = mesh.geometry;\n    var _b = geometry.attributes, color = _b.color, bar = _b.bar;\n    var positionIndex = 0;\n    var colorIndex = 0;\n    streamVertexSets.forEach(function (streamVertexSet, setIndex) {\n        streamVertexSet.forEach(function (currVertex) {\n            var currX = currVertex[0], currY = currVertex[1], r = currVertex[2], g = currVertex[3], b = currVertex[4];\n            /**\n             * Subtracting setIndex * getUniformWidth(dataStreams, toClipSpace) because with each new\n             * data stream, we want to render it side by side on the left side.\n             */\n            bar.array[positionIndex] = toClipSpace(currX) - setIndex * getUniformWidth(dataStreams, toClipSpace);\n            bar.array[positionIndex + 1] = currY;\n            // Set bar color (r, g, b)\n            color.array[colorIndex] = r;\n            color.array[colorIndex + 1] = g;\n            color.array[colorIndex + 2] = b;\n            // Increment Indexes by the associated stride of the buffer\n            colorIndex += NUM_COLOR_COMPONENTS;\n            positionIndex += NUM_POSITION_COMPONENTS;\n        });\n    });\n    bar.needsUpdate = true;\n    color.needsUpdate = true;\n};\n// https://wwwtyro.net/2019/11/18/instanced-lines.html\n// 2d vertices composing of two triangles which make up a square\n// (0, 1) - - - (1, 1)\n//   |  \\         |\n//   |     \\      |\n//   |        \\   |\n// (0, 0) - - - (1, 0)\nvar unitSquare = [0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1];\nvar initializeGeometry = function (geometry, bufferSize) {\n    geometry.setAttribute('position', new BufferAttribute(new Float32Array(unitSquare), NUM_POSITION_COMPONENTS));\n    geometry.setAttribute('bar', new InstancedBufferAttribute(new Float32Array(bufferSize * NUM_POSITION_COMPONENTS), NUM_POSITION_COMPONENTS, false));\n    geometry.setAttribute('color', new InstancedBufferAttribute(new Uint8Array(bufferSize * NUM_COLOR_COMPONENTS), NUM_COLOR_COMPONENTS, true));\n};\nvar barMesh = function (_a) {\n    var dataStreams = _a.dataStreams, dataStreamInfo = _a.dataStreamInfo, toClipSpace = _a.toClipSpace, bufferFactor = _a.bufferFactor, minBufferSize = _a.minBufferSize;\n    var instGeo = new InstancedBufferGeometry();\n    var bufferSize = Math.max(minBufferSize, numDataPoints(dataStreams) * bufferFactor);\n    // Create and populate geometry\n    initializeGeometry(instGeo, bufferSize);\n    /**\n     * Create Bar Mesh\n     *\n     * The representation of the bars on a bar chart.\n     *\n     * Utilizes an instance of a single unit square, which then gets\n     * stretched and transposed across the canvas.\n     */\n    var barChartMaterial = new RawShaderMaterial({\n        vertexShader: barVert,\n        fragmentShader: barFrag,\n        side: DoubleSide,\n        transparent: false,\n        uniforms: {\n            width: {\n                value: getUniformWidth(dataStreams, toClipSpace),\n            },\n        },\n    });\n    var mesh = new InstancedMesh(instGeo, barChartMaterial, bufferSize);\n    updateMesh({ dataStreams: dataStreams, dataStreamInfo: dataStreamInfo, mesh: mesh, toClipSpace: toClipSpace });\n    // Prevent bounding sphere from being called\n    mesh.frustumCulled = false;\n    return mesh;\n};\nvar updateBarMesh = function (_a) {\n    var bars = _a.bars, dataStreams = _a.dataStreams, dataStreamInfo = _a.dataStreamInfo, toClipSpace = _a.toClipSpace, hasDataChanged = _a.hasDataChanged;\n    if (hasDataChanged) {\n        // eslint-disable-next-line no-param-reassign\n        bars.material.uniforms.width.value = getUniformWidth(dataStreams, toClipSpace);\n        updateMesh({ dataStreams: dataStreams, dataStreamInfo: dataStreamInfo, mesh: bars, toClipSpace: toClipSpace });\n    }\n};\nvar maxDataPointsRendered = function (bars) { return bars.geometry.attributes.bar.array.length / NUM_POSITION_COMPONENTS; };\nvar chartScene = function (_a) {\n    var dataStreams = _a.dataStreams, dataStreamInfo = _a.dataStreamInfo, container = _a.container, viewPort = _a.viewPort, bufferFactor = _a.bufferFactor, minBufferSize = _a.minBufferSize;\n    var scene = new Scene();\n    var toClipSpace = clipSpaceConversion(viewPort);\n    scene.add(barMesh({ dataStreams: dataStreams, dataStreamInfo: dataStreamInfo, toClipSpace: toClipSpace, bufferFactor: bufferFactor, minBufferSize: minBufferSize }));\n    return constructChartScene({ scene: scene, viewPort: viewPort, container: container, toClipSpace: toClipSpace });\n};\nvar updateChartScene = function (_a) {\n    var scene = _a.scene, dataStreams = _a.dataStreams, dataStreamInfo = _a.dataStreamInfo, hasDataChanged = _a.hasDataChanged, minBufferSize = _a.minBufferSize, bufferFactor = _a.bufferFactor, viewPort = _a.viewPort, container = _a.container, chartSize = _a.chartSize;\n    var bars = scene.scene.children[0];\n    // If the amount of data being sent to the chart scene surpasses the size of the buffers within the\n    // chart scene, we must fully recreate the chart scene. This is a costly operation.\n    var isDataOverflowingBuffer = maxDataPointsRendered(bars) < numDataPoints(dataStreams);\n    if (isDataOverflowingBuffer || needsNewClipSpace(viewPort, scene.toClipSpace)) {\n        // TODO: fix me\n        return chartScene({\n            dataStreams: dataStreams,\n            dataStreamInfo: dataStreamInfo,\n            container: container,\n            viewPort: viewPort,\n            minBufferSize: minBufferSize,\n            bufferFactor: bufferFactor,\n            chartSize: chartSize,\n            thresholds: [],\n        });\n    }\n    updateBarMesh({\n        bars: bars,\n        dataStreams: dataStreams,\n        dataStreamInfo: dataStreamInfo,\n        toClipSpace: scene.toClipSpace,\n        hasDataChanged: hasDataChanged,\n    });\n    return scene;\n};\nexport { chartScene as c, updateChartScene as u };\n","import { r as registerInstance, h, g as getElement } from './index-326b73e4.js';\nimport './types-ef93b8eb.js';\nimport { D as DAY_IN_MS } from './time-cc688558.js';\nimport './_commonjsHelpers-17042db9.js';\nimport './utils-ef59b734.js';\nimport { w as webGLRenderer } from './webglContext-8b607584.js';\nimport './v4-1d709f5b.js';\nimport './index-085eab52.js';\nimport './predicates-4851c065.js';\nimport './clipSpaceConversion-2f416caa.js';\nimport { C as CHART_SIZE } from './chartSize-d34de530.js';\nimport { c as chartScene } from './chartScene-551b2a63.js';\n// viewport boundaries\nvar X_MIN = new Date(2000, 0, 0);\nvar X_MAX = new Date(2000, 0, 1);\nvar Y_MIN = 0;\nvar Y_MAX = 100;\nvar WIDTH = X_MAX.getTime() - X_MIN.getTime();\nvar HEIGHT = Y_MAX - Y_MIN;\nvar TEST_DATA_POINT_1 = {\n    x: new Date(X_MIN.getTime() + WIDTH / 3),\n    y: Y_MIN + HEIGHT / 2,\n};\nvar MonitorSingleColoredBar = /** @class */ (function () {\n    function MonitorSingleColoredBar(hostRef) {\n        registerInstance(this, hostRef);\n    }\n    MonitorSingleColoredBar.prototype.componentDidLoad = function () {\n        var container = this.el.querySelector('#test-container');\n        var scene = chartScene({\n            thresholds: [],\n            viewPort: {\n                start: X_MIN,\n                end: X_MAX,\n                yMin: Y_MIN,\n                yMax: Y_MAX,\n            },\n            dataStreams: [\n                {\n                    id: 'test-stream',\n                    data: [TEST_DATA_POINT_1],\n                    resolution: DAY_IN_MS,\n                },\n            ],\n            dataStreamInfo: [\n                {\n                    id: 'test-stream',\n                    name: 'test-stream-name',\n                    color: 'red',\n                },\n            ],\n            container: container,\n            chartSize: CHART_SIZE,\n            minBufferSize: 100,\n            bufferFactor: 2,\n        });\n        webGLRenderer.addChartScene(scene);\n        webGLRenderer.setChartRect(scene.id, container.getBoundingClientRect());\n    };\n    MonitorSingleColoredBar.prototype.render = function () {\n        return (h(\"monitor-webgl-context\", null, h(\"div\", { id: \"test-container\", style: { width: CHART_SIZE.width + \"px\", height: CHART_SIZE.height + \"px\" } })));\n    };\n    Object.defineProperty(MonitorSingleColoredBar.prototype, \"el\", {\n        get: function () { return getElement(this); },\n        enumerable: true,\n        configurable: true\n    });\n    return MonitorSingleColoredBar;\n}());\nexport { MonitorSingleColoredBar as monitor_single_colored_bar };\n","var SECOND_IN_MS = 1000;\nvar MINUTE_IN_MS = 60 * SECOND_IN_MS;\nvar HOUR_IN_MS = 60 * MINUTE_IN_MS;\nvar DAY_IN_MS = 24 * HOUR_IN_MS;\n// Not precisely accurate, only estimates. exact duration depends on start date. use with care.\nvar MONTH_IN_MS = 30 * DAY_IN_MS;\nvar YEAR_IN_MS = 12 * MONTH_IN_MS;\n/**\n * ConvertMS is a helper function that will take in milliseconds and convert it to the highest detonator\n * and does not return the \"remainder\"\n *\n * It is important to note that the object returning does not represent equivalence!\n *\n * For Example:\n * convert(MINUTE_IN_MS) will return:\n * {\n *   day: 0,\n *   hour: 0\n *   minute: 1,\n *   seconds: 0,\n * }\n *\n * IT DOES NOT RETURN:\n *\n * {\n *   day: 0,\n *   hour: 0,\n *   minute: 1,\n *   seconds: 60, <--- does not return the \"equivalence\"\n * }\n */\nvar convertMS = function (milliseconds) {\n    if (milliseconds < 0) {\n        throw new Error('Time cannot be negative!');\n    }\n    var seconds = Math.floor(milliseconds / 1000);\n    var minute = Math.floor(seconds / 60);\n    var hour = Math.floor(minute / 60);\n    var day = Math.floor(hour / 24);\n    seconds %= 60;\n    minute %= 60;\n    hour %= 24;\n    return {\n        day: day,\n        hour: hour,\n        minute: minute,\n        seconds: seconds,\n    };\n};\nvar displayDate = function (date, resolution, _a) {\n    var start = _a.start, end = _a.end;\n    if (resolution < DAY_IN_MS) {\n        var viewPortDurationMS = end.getTime() - start.getTime();\n        if (viewPortDurationMS < MINUTE_IN_MS) {\n            return date.toLocaleString('en-US', {\n                minute: 'numeric',\n                second: 'numeric',\n            });\n        }\n        if (viewPortDurationMS < 10 * MINUTE_IN_MS) {\n            return date.toLocaleString('en-US', {\n                hour: 'numeric',\n                minute: 'numeric',\n                second: 'numeric',\n                hour12: true,\n            });\n        }\n        return date.toLocaleString('en-US', {\n            hour: 'numeric',\n            minute: 'numeric',\n            hour12: true,\n        });\n    }\n    if (resolution <= HOUR_IN_MS) {\n        return date.toLocaleString('en-US', {\n            hour: 'numeric',\n            day: 'long',\n            hour12: true,\n        });\n    }\n    if (resolution <= DAY_IN_MS) {\n        return date.toLocaleString('en-US', {\n            day: 'numeric',\n            month: 'long',\n        });\n    }\n    return date.toLocaleString('en-US', {\n        year: 'numeric',\n        month: 'long',\n    });\n};\nexport { DAY_IN_MS as D, HOUR_IN_MS as H, MINUTE_IN_MS as M, SECOND_IN_MS as S, YEAR_IN_MS as Y, MONTH_IN_MS as a, convertMS as c, displayDate as d };\n","import { M as MINUTE_IN_MS, D as DAY_IN_MS, S as SECOND_IN_MS, Y as YEAR_IN_MS } from './time-cc688558.js';\n/**\n * Clip Space Conversion Utilities\n *\n * Our 'model' space utilizes milliseconds to represent time. This level of granularity is important\n * since we do wish to be able to visually represent the time differences at that level of detail.\n *\n * However, there are 3.15e+10 milliseconds in a year. This is problematic because it means that we cannot represent\n * a years worth of data at the millisecond level granularity utilizing 32 bit floats.\n *\n * double precision is not supported by webGL - there are ways to represent double precision, however these\n * are unnecessarily complicated, double our memory foot print, and actually not necessary.\n *\n * Interesting article on doubles: http://blog.hvidtfeldts.net/index.php/2012/07/double-precision-in-opengl-and-webgl/\n *\n * ## Why Not Necessary To Utilize Doubles?\n *\n * While we need millisecond level precision, we do not need to be able to visually differentiate between milliseconds\n * while looking at even a weeks worth of data. Even if we did, you would not be able to discern a difference\n * due to resolution limitations. Even if you had a hypothetically perfect monitor that could discern a planks-constant\n * level of resolution, the eye would not be able to tell without advanced optical instrumentation!\n *\n * ## Solution\n *\n * We do two things to mitigate - based on the time duration of a given viewport, we will scale down the numbers and\n * truncate the decimals such that the distance from the end to the start of the viewport is representable by a floating point.\n *\n * However, this leaves one more problem - imagine after scaling our viewport in our clip space, we could have\n * our start be 1.20001e+8 to 1.20002e+8, we would have a distance of 1000, which is representable by a 32 bit float, however\n * each number within that range is still not representable by a 32 bit float. To account for this, we also must translate our clip\n * space by what we refer to as an anchor. Suppose we utilize 1.2*10^8 as an anchor, our clip space time range is now 1000 to 2000.\n * Success! We can now represent our time within webgl by a 32 bit float.\n *\n * ## Caveats\n *\n * Since the viewport is dynamic, we have to make sure that as our viewport moves around, we update our `clip space conversion`.\n * Translating, scaling-in, and scaling-out can all cause our `clip space conversion` to start outputting numbers which are not representable by 32 bit floats.\n * To solve this, we also must make sure we watch for viewport changes and adjust our conversion accordingly.\n */\n/**\n * Granularity\n *\n * given a duration, return the granularity in milliseconds.\n * By granularity we mean the minimal time difference which is visually differentiated.\n */\nvar granularity = function (durationMS) {\n    if (durationMS < 10 * MINUTE_IN_MS) {\n        // single millisecond\n        return 1;\n    }\n    if (durationMS < DAY_IN_MS) {\n        return SECOND_IN_MS / 10;\n    }\n    if (durationMS < DAY_IN_MS * 7) {\n        return SECOND_IN_MS;\n    }\n    if (durationMS < YEAR_IN_MS) {\n        return MINUTE_IN_MS;\n    }\n    if (durationMS < 30 * YEAR_IN_MS) {\n        return 30 * MINUTE_IN_MS;\n    }\n    return DAY_IN_MS;\n};\n/**\n * Clip Space Conversion\n *\n * Converts something from model space (millisecond representation of time) into our clip space.\n * The goal is to be able to represent the time from `start` to `end` with floating point precision (7 significant digits).\n */\nvar clipSpaceConversion = function (viewPort) {\n    var durationMS = viewPort.end.getTime() - viewPort.start.getTime();\n    var anchorMS = viewPort.start.getTime() - durationMS * 0.25;\n    var granularityMS = granularity(durationMS);\n    return function (t) { return Math.floor((t - anchorMS) / granularityMS); };\n};\nvar FLOAT_SIG_FIGS = 7;\nvar isDateOutOfBounds = function (date, toClipSpace) { return Math.abs(toClipSpace(date.getTime())) >= Math.pow(10, FLOAT_SIG_FIGS); };\n// Minimum amount of distinct positions our clip spaces needs to represent.\nvar MIN_GRANULARITY = 3000;\n/**\n * Needs New Clip Space\n *\n * There are two conditions which can occur which will require a new clip space.\n *\n * 1. The viewport when mapped to the clip space, contains numbers that aren't representable by floating point precision.\n * 2. The granularity within the viewport mapped to the clip space is too low - i.e. if the viewport maps to [0, 10],\n *    then we can only represent 11 distinct points.\n */\nvar needsNewClipSpace = function (viewPort, toClipSpace) {\n    var isOutOfBounds = isDateOutOfBounds(viewPort.start, toClipSpace) || isDateOutOfBounds(viewPort.end, toClipSpace);\n    var distanceMS = viewPort.end.getTime() - viewPort.start.getTime();\n    var distanceClipSpace = toClipSpace(viewPort.end.getTime()) - toClipSpace(viewPort.start.getTime());\n    var hasTooLowGranularity = distanceMS > distanceClipSpace && distanceClipSpace < MIN_GRANULARITY;\n    return isOutOfBounds || hasTooLowGranularity;\n};\nexport { clipSpaceConversion as c, needsNewClipSpace as n };\n","import { W as WebGLRenderer } from './utils-ef59b734.js';\n/**\n * Convert a rect to a ClipSpaceRect\n *\n * This will return us the coordinates of a rectangle within clip space coordinates (i.e. coordinate space for webGL)\n * https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection to learn more about clip space\n */\nvar clipSpaceRect = function (containerRect, canvasRect) {\n    var density = window.devicePixelRatio;\n    var left = containerRect.left, bottom = containerRect.bottom, width = containerRect.width, height = containerRect.height;\n    var canvasHeight = canvasRect.height;\n    // The coordinate y-axis is flipped between the DOM and webGL so we must correct for that.\n    // Bounding client rect measures the bottom as the distance from the top, i.e.:\n    // For DOM, (0, 0) is the top left.\n    // In WebGL, (0, 0) is the bottom left.\n    var positiveYUpBottom = canvasHeight - (bottom - window.scrollY);\n    // Need to account for pixel density - i.e. retina display\n    var pixelLeft = (left - window.scrollX) * density;\n    var pixelBottom = positiveYUpBottom * density;\n    var pixelWidth = width * density;\n    var pixelHeight = height * density;\n    return {\n        left: pixelLeft,\n        bottom: pixelBottom,\n        width: pixelWidth,\n        height: pixelHeight,\n    };\n};\n/**\n * Return a rect with the property of being unchanged upon scrolling.\n *\n * The reason this is desirable is because it allows us to not have to re-calculate all our\n * rect's every time a scroll event occurs. This allows for a smooth scroll to occur.\n */\nvar rectScrollFixed = function (el) {\n    var domRect = el.getBoundingClientRect();\n    return {\n        width: domRect.width,\n        height: domRect.height,\n        left: domRect.left + window.scrollX,\n        right: domRect.right + window.scrollX,\n        bottom: domRect.bottom + window.scrollY,\n        top: domRect.top + window.scrollY,\n        x: domRect.x + window.scrollX,\n        y: domRect.y + window.scrollY,\n    };\n};\n/**\n * A map of clip-space rectangles for chart scenes.\n *\n * Allows us to track what region in clip-space each chart scene should be rendered in.\n * The goal is to not have to continually make calls to `getBoundingClientRect` since it is an expsensive operation\n * which causes layouts to be re-calculated: http://dcousineau.com/blog/2013/09/03/high-performance-js-tip/\n */\nvar ClipSpaceRectMap = /** @class */ (function () {\n    function ClipSpaceRectMap(canvas) {\n        this.rectMap = {};\n        this.canvas = canvas;\n        this.updateCanvas();\n    }\n    /**\n     * Update DOMRect for canvas\n     */\n    ClipSpaceRectMap.prototype.updateCanvas = function () {\n        this.canvasRect = this.canvas.getBoundingClientRect();\n    };\n    /**\n     * Updates the rect for the requested chart scene\n     */\n    ClipSpaceRectMap.prototype.updateChartScene = function (chartSceneId, rect) {\n        this.rectMap[chartSceneId] = rect;\n    };\n    /**\n     * Return clip rect for the requested chart scene\n     */\n    ClipSpaceRectMap.prototype.clipRect = function (chartSceneId) {\n        return this.rectMap[chartSceneId] ? clipSpaceRect(this.rectMap[chartSceneId], this.canvasRect) : undefined;\n    };\n    /**\n     * Remove chart scene from rect map\n     */\n    ClipSpaceRectMap.prototype.removeChartScene = function (chartSceneId) {\n        delete this.rectMap[chartSceneId];\n    };\n    return ClipSpaceRectMap;\n}());\n/* eslint-disable @typescript-eslint/no-use-before-define */\n/**\n * Render Scene Info\n *\n * Renders a single chart scene, which will represent a single, rectangular view of data\n * within the shared WebGL context.\n *\n * This technique is inspired by https://threejsfundamentals.org/threejs/lessons/threejs-multiple-scenes.html\n * In summary, each chart scene has an HTML element  - and the associated scene is rendered to overlay on the\n * rectangle defined by the given HTML element.\n */\nvar renderChartScene = function (renderer, _a, _b) {\n    var scene = _a.scene, camera = _a.camera;\n    var left = _b.left, bottom = _b.bottom, width = _b.width, height = _b.height;\n    renderer.setScissor(left, bottom, width, height);\n    renderer.setViewport(left, bottom, width, height);\n    renderer.render(scene, camera);\n};\nfunction resizeRendererToDisplaySize(renderer) {\n    var canvas = renderer.domElement;\n    var width = Math.floor(canvas.clientWidth * window.devicePixelRatio) || 0;\n    var height = Math.floor(canvas.clientHeight * window.devicePixelRatio) || 0;\n    var needResize = canvas.width !== width || canvas.height !== height;\n    if (needResize) {\n        renderer.setSize(width, height, false);\n    }\n    return needResize;\n}\n/**\n * Create a webGL renderer\n *\n * Creates a single webGL rendering context which can be shared across different visualizations.\n * The primary motivator for sharing a single WebGL context is due to the overhead and limitations on making multiple WebGL Context.\n * Resources such as buffered data and textures cannot be shared across WebGL Contexts, and furthermore, due to performance considerations\n * of have many WebGL Contexts, certain browsers have a hard limit on the number of active WebGL Contexts.\n *\n * Refer to https://stackoverflow.com/questions/59140439/allowing-more-webgl-contexts for additional context.\n */\nvar createWebGLRenderer = function () {\n    var rectMap;\n    // List of chart scenes to render in every animation loop.\n    // chart scenes should be mutated to update what gets rendered.\n    var chartScenes = [];\n    /**\n     * Add Chart Scene\n     *\n     * Adds a chart scene to be rendered within the webGL context.\n     * Once added, the given `ChartScene` will be part of the animation loop until explicitly removed.\n     */\n    var addChartScene = function (chartScene) {\n        chartScenes.push(chartScene);\n    };\n    /**\n     * Remove Chart Scene\n     *\n     * Remove and dispose of a given scene.\n     */\n    var removeChartScene = function (chartSceneId) {\n        var chartScene = chartScenes.find(function (s) { return s.id === chartSceneId; });\n        // Remove chart scene from list of registered chart scenes\n        chartScenes = chartScenes.filter(function (s) { return s.id !== chartSceneId; });\n        // Dispose of the chart scene to ensure that the memory is released\n        if (chartScene) {\n            chartScene.dispose();\n        }\n        rectMap.removeChartScene(chartSceneId);\n        fullClearAndRerender();\n    };\n    var syncCameras = function (start, end) {\n        chartScenes.forEach(function (scene) {\n            scene.updateViewPort(start, end);\n            render(scene);\n        });\n    };\n    /**\n     * Initiate Rendering Loop\n     *\n     * Begins a rendering loop to render all chart streams onto the provided canvas\n     */\n    var renderer;\n    var canvas;\n    var fullClearAndRerender = function () {\n        if (renderer) {\n            // Turn off scissor test to make the clear effect the entire canvas\n            renderer.setScissorTest(false);\n            renderer.clear();\n            renderer.setScissorTest(true);\n            // Re-render every chart scene. Necessary since entire canvas has been cleared\n            chartScenes.forEach(render);\n        }\n    };\n    var onScroll = function () {\n        if (renderer && canvas) {\n            var transform = \"translate(\" + window.scrollX + \"px, \" + window.scrollY + \"px)\";\n            // eslint-disable-next-line no-param-reassign\n            renderer.domElement.style.transform = transform;\n            rectMap.updateCanvas();\n            fullClearAndRerender();\n        }\n    };\n    var onResize = function () {\n        if (renderer && canvas) {\n            resizeRendererToDisplaySize(renderer);\n            rectMap.updateCanvas();\n            fullClearAndRerender();\n        }\n    };\n    var initRendering = function (renderCanvas) {\n        rectMap = new ClipSpaceRectMap(renderCanvas);\n        canvas = renderCanvas;\n        renderer = new WebGLRenderer({ canvas: canvas, alpha: true, antialias: true, preserveDrawingBuffer: true });\n        // Enable scissor test, which allows us to render our visualizations to a subset of the canvas\n        // https://threejs.org/docs/#api/en/renderers/WebGLRenderer.setScissor\n        // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/scissor\n        renderer.setScissorTest(true);\n        renderer.setClearColor(0x000000, 0); // transparent clear\n        onScroll();\n        onResize();\n        window.addEventListener('scroll', onScroll);\n        window.addEventListener('resize', onResize);\n    };\n    var render = function (chartScene) {\n        var clipSpaceRect = rectMap.clipRect(chartScene.id);\n        if (renderer && canvas && clipSpaceRect) {\n            renderChartScene(renderer, chartScene, clipSpaceRect);\n        }\n    };\n    var dispose = function () {\n        if (renderer) {\n            chartScenes.map(function (_a) {\n                var id = _a.id;\n                return id;\n            }).forEach(removeChartScene);\n            renderer.dispose();\n        }\n        window.removeEventListener('scroll', onScroll);\n        window.removeEventListener('resize', onResize);\n    };\n    /**\n     * Registers the position and dimension of where the requested chart scene renders to.\n     * Clears the previous renderer location if it exists.\n     */\n    var setChartRect = function (sceneId, rect) {\n        rectMap.updateChartScene(sceneId, rect);\n        fullClearAndRerender();\n    };\n    return {\n        initRendering: initRendering,\n        dispose: dispose,\n        render: render,\n        addChartScene: addChartScene,\n        removeChartScene: removeChartScene,\n        setChartRect: setChartRect,\n        syncCameras: syncCameras,\n    };\n};\n// TODO(btd): Rather than exposing this as a singleton, it would be preferred to expose it as\n//  a shared context within a component sub-tree.\nvar webGLRenderer = createWebGLRenderer();\nexport { rectScrollFixed as r, webGLRenderer as w };\n"],"sourceRoot":""}